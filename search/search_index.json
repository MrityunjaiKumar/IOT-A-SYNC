{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to IOT-A-SYNC Documentation This is the documentation for the IOT-A-SYNC board. What is IOT-A-SYNC? IOT-A-SYNC is rapid prototyping development board for Internet of Things (IOT) applications. This board is powered by ESP32 sytem on chip microcontroller with Xtensa dual-core. Esp32 officially supports Arduino and ESP-IDF framework built around FreeRTOS. Origin of design This porduct was developed at CEDT, NSUT. Sicgrid was involved in designing process and currently mass manufacturing and markting it. NIC Interfaces available on IOTA-SYNC IOT-A-SYNC supports multiple globally accepted network interfaces for IOT devices communication. Various wireless communicaton options it supports are WIFI, BLE,NFC, LoRa PHY. NIC Interfaces in terms of range In terms of range of commuincation, For Short range, it supports NFC. For Medium range, it supports Wi-Fi (802.11 b/g/n) and Bluetooth (v4.2 BR/EDR and BLE). For Long range, it supports LoRa communication. Topolgy of network that can be demonstrated IOT-A-SYNC also support network topology like Star and Mesh for creating Wireless sensor network(WSN). Programming and Debugging interfaces available Programming of IOT-A-SYNC is supported by onboard USB-to-Serial converter as well as it also supports external JTAG interface for programming and debugging. On board preipherals Other on board peripherals that are available icludes:- On-Board Led, Switch, Oled(128x64) screen, BME280 sensor (provides Temperatue, Humidity, Pressue), IR transmitter led and IR Receiver sensor. All I/O pins are provide on 0.1\" male as well as female header, as well as few distictive feature I/O are available on 3 Pin JST connector compatible with commonly available sensors and other modules. The 180-point breadboard further facilitates temporary/external circuit testing via jumpers on board itself. Low power mode Also, for low power WSN, shorting jumpers are provided to limit power usuage. Some example code repository URL for ESP32-IOTA-SYNC repository: ESP32-IOTA-SYNC URL for Design and Practicum Workshop: DPW ESP32 Functional block diagram of ESP32 Dual core processor The predecessor of ESP32, the ESP8266 has a builtin processor. However due to multitasking involved in updating the WiFi stack, most of the applications use a separate micro-controller for data processing, interfacing sensors and digital Input Output. With the ESP32 you may not want to use an additional micro-controller. ESP32 has Xtensa\u00ae Dual-Core 32-bit LX6 microprocessors, which runs up to 600 DMIPS. The ESP32 will run on breakout boards and modules from 160Mhz upto 240MHz . That is very good speed for anything that requires a microcontroller with connectivity options. The two cores are named Protocol CPU (PRO_CPU) and Application CPU (APP_CPU). That basically means the PRO_CPU processor handles the WiFi, Bluetooth and other internal peripherals like SPI, I2C, ADC etc. The APP_CPU is left out for the application code. This differentiation is done in the Espressif Internet Development Framework (ESP-IDF). ESP-IDF is the official software development framework for the chip. Arduino and other implementations for the development will be based on ESP-IDF. ESP-IDF uses freeRTOS for switching between the processors and data exchange between them. We have done numerous tutorials on freeRTOS and with all the bare-metal programming tutorials for ESP32 we will try and cover this aspect in detail. Although the feature set is great at the price at which the chip is being sold, the complexity is enormous. For the chip to get widely adopted, it will require huge efforts from Espressif as well as the community","title":"Introduction"},{"location":"#welcome-to-iot-a-sync-documentation","text":"This is the documentation for the IOT-A-SYNC board.","title":"Welcome to IOT-A-SYNC Documentation"},{"location":"#what-is-iot-a-sync","text":"IOT-A-SYNC is rapid prototyping development board for Internet of Things (IOT) applications. This board is powered by ESP32 sytem on chip microcontroller with Xtensa dual-core. Esp32 officially supports Arduino and ESP-IDF framework built around FreeRTOS.","title":"What is IOT-A-SYNC?"},{"location":"#origin-of-design","text":"This porduct was developed at CEDT, NSUT. Sicgrid was involved in designing process and currently mass manufacturing and markting it.","title":"Origin of design"},{"location":"#nic-interfaces-available-on-iota-sync","text":"IOT-A-SYNC supports multiple globally accepted network interfaces for IOT devices communication. Various wireless communicaton options it supports are WIFI, BLE,NFC, LoRa PHY.","title":"NIC Interfaces available on IOTA-SYNC"},{"location":"#nic-interfaces-in-terms-of-range","text":"In terms of range of commuincation, For Short range, it supports NFC. For Medium range, it supports Wi-Fi (802.11 b/g/n) and Bluetooth (v4.2 BR/EDR and BLE). For Long range, it supports LoRa communication.","title":"NIC Interfaces in terms of range"},{"location":"#topolgy-of-network-that-can-be-demonstrated","text":"IOT-A-SYNC also support network topology like Star and Mesh for creating Wireless sensor network(WSN).","title":"Topolgy of network that can be demonstrated"},{"location":"#programming-and-debugging-interfaces-available","text":"Programming of IOT-A-SYNC is supported by onboard USB-to-Serial converter as well as it also supports external JTAG interface for programming and debugging.","title":"Programming and Debugging interfaces available"},{"location":"#on-board-preipherals","text":"Other on board peripherals that are available icludes:- On-Board Led, Switch, Oled(128x64) screen, BME280 sensor (provides Temperatue, Humidity, Pressue), IR transmitter led and IR Receiver sensor. All I/O pins are provide on 0.1\" male as well as female header, as well as few distictive feature I/O are available on 3 Pin JST connector compatible with commonly available sensors and other modules. The 180-point breadboard further facilitates temporary/external circuit testing via jumpers on board itself.","title":"On board preipherals"},{"location":"#low-power-mode","text":"Also, for low power WSN, shorting jumpers are provided to limit power usuage.","title":"Low power mode"},{"location":"#some-example-code-repository","text":"URL for ESP32-IOTA-SYNC repository: ESP32-IOTA-SYNC URL for Design and Practicum Workshop: DPW","title":"Some example code repository"},{"location":"#esp32","text":"","title":"ESP32"},{"location":"#functional-block-diagram-of-esp32","text":"","title":"Functional block diagram of ESP32"},{"location":"#dual-core-processor","text":"The predecessor of ESP32, the ESP8266 has a builtin processor. However due to multitasking involved in updating the WiFi stack, most of the applications use a separate micro-controller for data processing, interfacing sensors and digital Input Output. With the ESP32 you may not want to use an additional micro-controller. ESP32 has Xtensa\u00ae Dual-Core 32-bit LX6 microprocessors, which runs up to 600 DMIPS. The ESP32 will run on breakout boards and modules from 160Mhz upto 240MHz . That is very good speed for anything that requires a microcontroller with connectivity options. The two cores are named Protocol CPU (PRO_CPU) and Application CPU (APP_CPU). That basically means the PRO_CPU processor handles the WiFi, Bluetooth and other internal peripherals like SPI, I2C, ADC etc. The APP_CPU is left out for the application code. This differentiation is done in the Espressif Internet Development Framework (ESP-IDF). ESP-IDF is the official software development framework for the chip. Arduino and other implementations for the development will be based on ESP-IDF. ESP-IDF uses freeRTOS for switching between the processors and data exchange between them. We have done numerous tutorials on freeRTOS and with all the bare-metal programming tutorials for ESP32 we will try and cover this aspect in detail. Although the feature set is great at the price at which the chip is being sold, the complexity is enormous. For the chip to get widely adopted, it will require huge efforts from Espressif as well as the community","title":"Dual core processor"},{"location":"Arduino/","text":"Basic Functions that can be used with ESP32 ESP32 uses many functions that are very similar to many arduino boards, the only difference is that some parameters have to be changed according to the hardware limitation of this board. Pinout diagram Basic functions The pins of ESP32 is connected to various connectors of IOT-A-SYNC, verify it before starting Some of the basic functions that can be used are given below: pinMode This function lets the controller know weather the GPIO pin will act as Input or Output. digitalWrite This command instructs a particular GPIO pin to go logic HIGH or logic LOW as per the arguments. 1 2 digitalWrite ( GPIO_pin_number , HIGH ); //This gives logic HIGH (3.3V) digitalWrite ( GPIO_pin_number , LOW ); //This gives logic LOW (0V) digitalRead This command checks the digital logic voltage at a particular pin specified as arguments. It returns a boolean TRUE if logic detected is HIGH at that pin and FALSE if logic LOW is detected. 1 digitalRead ( GPIO_pin_number ); analogRead This reads the analog value at the pin specified as argument. Since it has 12bit ADC (analog-to-digital convertor) it can only read voltages in discrete intervals of 2^8 (i.e 2^(no. of bits)), therefore it can read upto an accuracy of 3.3/(2^8) = 0.805mV. 1 analogRead ( GPIO_pin_number ); Writing Ananlog values ESP32 does not have analogWrite() function. So we use different methods to generate analog signals. One such method is using PWM and other is using the inbuilt DAC hardware. Using DAC DacWrite(GPIO_pin,value); //'value' defined ranges from 0 to 4095 as it uses a 12 bit DAC. Using PWM Here we use the concept that in a pulsed wave the average output is (max Voltage)X(duty cycle). Thus this method can be used to vary the brightness of an LED, vary the sound in a speaker, vary the speed of motors and many more. For this, we define a particular frequency with which we want to send PWM (For lighting LEDs it should be much higher than the persistence of vision, for motors it should be according to the time constant). The duty cycle can be varied by keeping the output HIGH for some time and LOW for the rest of the time. See this example to get an overview on how to code for PWM. delay() This function lets the controller to wait for certain millisecons (as specified in the argumenmt) before executing the next instruction. When the delay is executed, the controller cannot do any other task, it\u2019s like being in a \u2018paused\u2019 state. 1 delay ( 1000 ); //delay of 1000ms i.e.1sec Similar function is delayMicroseconds() . Millis() - This function returns the time in milliseconds that have been passed since program execution has started. It has overflow time of about 50 days! Interrupts Interrupt is a signal emitted by hardware or software when a process or an event needs immediate attention. It alerts the processor to a high priority process requiring interruption of the current working process. In I/O devices one of the bus control lines is dedicated for this purpose and is called the Interrupt Service Routine (ISR). When a device raises an interrupt at lets say process i, the processor first completes the execution of instruction i. Then it loads the Program Counter (PC) with the address of the first instruction of the ISR. Before loading the Program Counter with the address, the address of the interrupted instruction is moved to a temporary location. Therefore, after handling the interrupt the processor can continue with process i+1. Interrupts here can be callled in four ways/Modes:- LOW to trigger the interrupt whenever the pin is low, CHANGE to trigger the interrupt whenever the pin changes value RISING to trigger when the pin goes from low to high, FALLING for when the pin goes from high to low. All GPIO pins can be configered as Interrupt pins attachInterrupt() This tells the controller on which pin the interrupt has to be attached and what ISR does it corresponds. attachInterrupt(GPIO_Pin_no, ISR, Mode); 1 2 //'ISR' is a function which is called when interrupt is received. ISR has to be as small as possible. //'Mode' specifies the event when interrupt should be called. detachInterrupt(pin_no) It disables the interrupt at that pin. Serial Class This is a class predefined in the \u201cArduino.h\u201d library for serial communication. It consists of many functions which are used for manipulating data. This has extreme importance in UART communication. Visit: https://www.arduino.cc/reference/en/language/functions/communication/serial/ to know more about functions available in this class.","title":"Arduino FrameWork"},{"location":"Arduino/#basic-functions-that-can-be-used-with-esp32","text":"ESP32 uses many functions that are very similar to many arduino boards, the only difference is that some parameters have to be changed according to the hardware limitation of this board.","title":"Basic Functions that can be used with ESP32"},{"location":"Arduino/#pinout-diagram","text":"","title":"Pinout diagram"},{"location":"Arduino/#basic-functions","text":"The pins of ESP32 is connected to various connectors of IOT-A-SYNC, verify it before starting Some of the basic functions that can be used are given below:","title":"Basic functions"},{"location":"Arduino/#pinmode","text":"This function lets the controller know weather the GPIO pin will act as Input or Output.","title":"pinMode"},{"location":"Arduino/#digitalwrite","text":"This command instructs a particular GPIO pin to go logic HIGH or logic LOW as per the arguments. 1 2 digitalWrite ( GPIO_pin_number , HIGH ); //This gives logic HIGH (3.3V) digitalWrite ( GPIO_pin_number , LOW ); //This gives logic LOW (0V)","title":"digitalWrite"},{"location":"Arduino/#digitalread","text":"This command checks the digital logic voltage at a particular pin specified as arguments. It returns a boolean TRUE if logic detected is HIGH at that pin and FALSE if logic LOW is detected. 1 digitalRead ( GPIO_pin_number );","title":"digitalRead"},{"location":"Arduino/#analogread","text":"This reads the analog value at the pin specified as argument. Since it has 12bit ADC (analog-to-digital convertor) it can only read voltages in discrete intervals of 2^8 (i.e 2^(no. of bits)), therefore it can read upto an accuracy of 3.3/(2^8) = 0.805mV. 1 analogRead ( GPIO_pin_number );","title":"analogRead"},{"location":"Arduino/#writing-ananlog-values","text":"ESP32 does not have analogWrite() function. So we use different methods to generate analog signals. One such method is using PWM and other is using the inbuilt DAC hardware.","title":"Writing Ananlog values"},{"location":"Arduino/#using-dac","text":"DacWrite(GPIO_pin,value); //'value' defined ranges from 0 to 4095 as it uses a 12 bit DAC.","title":"Using DAC"},{"location":"Arduino/#using-pwm","text":"Here we use the concept that in a pulsed wave the average output is (max Voltage)X(duty cycle). Thus this method can be used to vary the brightness of an LED, vary the sound in a speaker, vary the speed of motors and many more. For this, we define a particular frequency with which we want to send PWM (For lighting LEDs it should be much higher than the persistence of vision, for motors it should be according to the time constant). The duty cycle can be varied by keeping the output HIGH for some time and LOW for the rest of the time. See this example to get an overview on how to code for PWM.","title":"Using PWM"},{"location":"Arduino/#delay","text":"This function lets the controller to wait for certain millisecons (as specified in the argumenmt) before executing the next instruction. When the delay is executed, the controller cannot do any other task, it\u2019s like being in a \u2018paused\u2019 state. 1 delay ( 1000 ); //delay of 1000ms i.e.1sec Similar function is delayMicroseconds() . Millis() - This function returns the time in milliseconds that have been passed since program execution has started. It has overflow time of about 50 days!","title":"delay()"},{"location":"Arduino/#interrupts","text":"Interrupt is a signal emitted by hardware or software when a process or an event needs immediate attention. It alerts the processor to a high priority process requiring interruption of the current working process. In I/O devices one of the bus control lines is dedicated for this purpose and is called the Interrupt Service Routine (ISR). When a device raises an interrupt at lets say process i, the processor first completes the execution of instruction i. Then it loads the Program Counter (PC) with the address of the first instruction of the ISR. Before loading the Program Counter with the address, the address of the interrupted instruction is moved to a temporary location. Therefore, after handling the interrupt the processor can continue with process i+1. Interrupts here can be callled in four ways/Modes:- LOW to trigger the interrupt whenever the pin is low, CHANGE to trigger the interrupt whenever the pin changes value RISING to trigger when the pin goes from low to high, FALLING for when the pin goes from high to low. All GPIO pins can be configered as Interrupt pins","title":"Interrupts"},{"location":"Arduino/#attachinterrupt","text":"This tells the controller on which pin the interrupt has to be attached and what ISR does it corresponds. attachInterrupt(GPIO_Pin_no, ISR, Mode); 1 2 //'ISR' is a function which is called when interrupt is received. ISR has to be as small as possible. //'Mode' specifies the event when interrupt should be called. detachInterrupt(pin_no) It disables the interrupt at that pin. Serial Class This is a class predefined in the \u201cArduino.h\u201d library for serial communication. It consists of many functions which are used for manipulating data. This has extreme importance in UART communication. Visit: https://www.arduino.cc/reference/en/language/functions/communication/serial/ to know more about functions available in this class.","title":"attachInterrupt()"},{"location":"Bluetooth/","text":"Bluetooth Bluetooth is a wireless technology standard for exchanging data over short distances, with advantages including robustness, low power consumption and low cost. The Bluetooth system can be divided into two different categories: Classic Bluetooth and Bluetooth Low Energy (BLE). ESP32 supports dual-mode Bluetooth, meaning that both Classic Bluetooth and BLE are supported by ESP32. It operaters at 2.4GHz. Bluetooth Radio and Baseband The Bluetooth Radio and Baseband support the following features: \u2022 Class-1, class-2 and class-3 transmit output powers, and a dynamic control range of up to 24 dB \u2022 \u03c0/4 DQPSK and 8 DPSK modulation \u2022 High performance in NZIF receiver sensitivity with over 94 dBm of dynamic range \u2022 Class-1 operation without external PA \u2022 Internal SRAM allows full-speed data-transfer, mixed voice and data, and full piconet operation \u2022 Logic for forward error correction, header error control, access code correlation, CRC, demodulation, encryption bit stream generation, whitening and transmit pulse shaping \u2022 ACL, SCO, eSCO and AFH \u2022 A-law, \u00b5-law and CVSD digital audio CODEC in PCM interface \u2022 SBC audio CODEC \u2022 Power management for low-power applications \u2022 SMP with 128-bit AES Bluetooth Interface \u2022 Provides UART HCI interface, up to 4 Mbps \u2022 Provides SDIO / SPI HCI interface \u2022 Provides PCM / I\u00b2S audio interface Bluetooth Stack The Bluetooth stack of the chip is compliant with the Bluetooth v4.2 BR/EDR and Bluetooth LE specifications. Piconet and Scatternet Device supports both Piconet and Scatternet. Bluetooth Profiles Bluetooth profiles are additional protocols that build upon the basic Bluetooth standard to more clearly define what kind of data a Bluetooth module is transmitting. While Bluetooth specifications define how the technology works, profiles define how it's used. The profile(s) a Bluetooth device supports determine(s) what application it's geared towards. A hands-free Bluetooth headset, for example, would use headset profile (HSP), while a Nintendo Wii Controller would implement the human interface device (HID) profile. For two Bluetooth devices to be compatible, they must support the same profiles. Few of the more commonly-encountered Bluetooth profiles:- Serial Port Profile (SPP) Human Interface Device (HID) Hands-Free Profile (HFP) and Headset Profile (HSP) Advanced Audio Distribution Profile (A2DP) A/V Remote Control Profile (AVRCP) Related links ESP32Bluetooth Architecture","title":"Bluetooth Introduction"},{"location":"Bluetooth/#bluetooth","text":"Bluetooth is a wireless technology standard for exchanging data over short distances, with advantages including robustness, low power consumption and low cost. The Bluetooth system can be divided into two different categories: Classic Bluetooth and Bluetooth Low Energy (BLE). ESP32 supports dual-mode Bluetooth, meaning that both Classic Bluetooth and BLE are supported by ESP32. It operaters at 2.4GHz.","title":"Bluetooth"},{"location":"Bluetooth/#bluetooth-radio-and-baseband","text":"The Bluetooth Radio and Baseband support the following features: \u2022 Class-1, class-2 and class-3 transmit output powers, and a dynamic control range of up to 24 dB \u2022 \u03c0/4 DQPSK and 8 DPSK modulation \u2022 High performance in NZIF receiver sensitivity with over 94 dBm of dynamic range \u2022 Class-1 operation without external PA \u2022 Internal SRAM allows full-speed data-transfer, mixed voice and data, and full piconet operation \u2022 Logic for forward error correction, header error control, access code correlation, CRC, demodulation, encryption bit stream generation, whitening and transmit pulse shaping \u2022 ACL, SCO, eSCO and AFH \u2022 A-law, \u00b5-law and CVSD digital audio CODEC in PCM interface \u2022 SBC audio CODEC \u2022 Power management for low-power applications \u2022 SMP with 128-bit AES","title":"Bluetooth Radio and Baseband"},{"location":"Bluetooth/#bluetooth-interface","text":"\u2022 Provides UART HCI interface, up to 4 Mbps \u2022 Provides SDIO / SPI HCI interface \u2022 Provides PCM / I\u00b2S audio interface","title":"Bluetooth Interface"},{"location":"Bluetooth/#bluetooth-stack","text":"The Bluetooth stack of the chip is compliant with the Bluetooth v4.2 BR/EDR and Bluetooth LE specifications.","title":"Bluetooth Stack"},{"location":"Bluetooth/#piconet-and-scatternet","text":"Device supports both Piconet and Scatternet.","title":"Piconet and Scatternet"},{"location":"Bluetooth/#bluetooth-profiles","text":"Bluetooth profiles are additional protocols that build upon the basic Bluetooth standard to more clearly define what kind of data a Bluetooth module is transmitting. While Bluetooth specifications define how the technology works, profiles define how it's used. The profile(s) a Bluetooth device supports determine(s) what application it's geared towards. A hands-free Bluetooth headset, for example, would use headset profile (HSP), while a Nintendo Wii Controller would implement the human interface device (HID) profile. For two Bluetooth devices to be compatible, they must support the same profiles. Few of the more commonly-encountered Bluetooth profiles:- Serial Port Profile (SPP) Human Interface Device (HID) Hands-Free Profile (HFP) and Headset Profile (HSP) Advanced Audio Distribution Profile (A2DP) A/V Remote Control Profile (AVRCP)","title":"Bluetooth Profiles"},{"location":"Bluetooth/#related-links","text":"ESP32Bluetooth Architecture","title":"Related links"},{"location":"Bluetooth/BLE-MESH/","text":"BLE-MESH With various features of ESP-BLE-MESH, users can create a managed flooding mesh network for several scenarios, such as lighting, sensor and etc. For an ESP32 to join and work on a ESP-BLE-MESH network, it must be provisioned firstly. By provisioning, the ESP32, as an unprovisioned device, will join the ESP-BLE-MESH network and become a ESP-BLE-MESH node, communicating with other nodes within or beyond the radio range. Apart from ESP-BLE-MESH nodes, inside ESP-BLE-MESH network, there is also ESP32 that works as ESP-BLE-MESH Provisioner, which could provision unprovisioned devices into ESP-BLE-MESH nodes and configure the nodes with various features. For information how to start using ESP32 and ESP-BLE-MESH, please see the Section Getting Started with ESP-BLE-MESH .","title":"BLE-MESH"},{"location":"Bluetooth/BLE-MESH/#ble-mesh","text":"With various features of ESP-BLE-MESH, users can create a managed flooding mesh network for several scenarios, such as lighting, sensor and etc. For an ESP32 to join and work on a ESP-BLE-MESH network, it must be provisioned firstly. By provisioning, the ESP32, as an unprovisioned device, will join the ESP-BLE-MESH network and become a ESP-BLE-MESH node, communicating with other nodes within or beyond the radio range. Apart from ESP-BLE-MESH nodes, inside ESP-BLE-MESH network, there is also ESP32 that works as ESP-BLE-MESH Provisioner, which could provision unprovisioned devices into ESP-BLE-MESH nodes and configure the nodes with various features. For information how to start using ESP32 and ESP-BLE-MESH, please see the Section Getting Started with ESP-BLE-MESH .","title":"BLE-MESH"},{"location":"Bluetooth/BLE/","text":"BLE What is BLE? Bluetooth Low Energy, BLE for short, is a power-conserving variant of Bluetooth. BLE\u2019s primary application is short distance transmission of small amounts of data (low bandwidth). Unlike Bluetooth that is always on, BLE remains in sleep mode constantly except for when a connection is initiated. The link controller operates in three major states: standby, connection and sniff. It enables multiple connections, and other operations, such as inquiry, page, and secure simple-pairing, and therefore enables Piconet and Scatternet. Below are the features: Bluetooth Low Energy Advertising Scanning Simultaneous advertising and scanning Multiple connections Asynchronous data reception and transmission Adaptive Frequency Hopping and Channel assessment Connection parameter update Data Length Extension Link Layer Encryption LE Ping Example SimpleBleDevice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Sketch shows how to use SimpleBLE to advertise the a //random number from device and change it on the press of a button // Useful if you want to advertise some sort of message // Button is attached between GPIO 0 and GND, //and the device name changes each time the button is pressed #include \"SimpleBLE.h\" #if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED) #error Bluetooth is not enabled! Please run `make menuconfig` to and enable it #endif SimpleBLE ble ; void onButton (){ String out = \"random no. : \" ; out += String ( millis () / 1000 ); Serial . println ( out ); ble . begin ( out ); } void setup () { Serial . begin ( 115200 ); Serial . setDebugOutput ( true ); pinMode ( 4 , INPUT ); Serial . print ( \"ESP32 SDK: \" ); Serial . println ( ESP . getSdkVersion ()); ble . begin ( \"ESP32 BLE Button\" ); Serial . println ( \"Press the button to change the device's name\" ); } void loop () { static uint8_t lastPinState = 1 ; uint8_t pinState = digitalRead ( 4 ); if ( ! pinState && lastPinState ){ onButton (); } lastPinState = pinState ; while ( Serial . available ()) Serial . write ( Serial . read ()); } Demo","title":"Bluetooth Low Energy"},{"location":"Bluetooth/BLE/#ble","text":"","title":"BLE"},{"location":"Bluetooth/BLE/#what-is-ble","text":"Bluetooth Low Energy, BLE for short, is a power-conserving variant of Bluetooth. BLE\u2019s primary application is short distance transmission of small amounts of data (low bandwidth). Unlike Bluetooth that is always on, BLE remains in sleep mode constantly except for when a connection is initiated. The link controller operates in three major states: standby, connection and sniff. It enables multiple connections, and other operations, such as inquiry, page, and secure simple-pairing, and therefore enables Piconet and Scatternet. Below are the features: Bluetooth Low Energy Advertising Scanning Simultaneous advertising and scanning Multiple connections Asynchronous data reception and transmission Adaptive Frequency Hopping and Channel assessment Connection parameter update Data Length Extension Link Layer Encryption LE Ping","title":"What is BLE?"},{"location":"Bluetooth/BLE/#example","text":"","title":"Example"},{"location":"Bluetooth/BLE/#simplebledevice","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Sketch shows how to use SimpleBLE to advertise the a //random number from device and change it on the press of a button // Useful if you want to advertise some sort of message // Button is attached between GPIO 0 and GND, //and the device name changes each time the button is pressed #include \"SimpleBLE.h\" #if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED) #error Bluetooth is not enabled! Please run `make menuconfig` to and enable it #endif SimpleBLE ble ; void onButton (){ String out = \"random no. : \" ; out += String ( millis () / 1000 ); Serial . println ( out ); ble . begin ( out ); } void setup () { Serial . begin ( 115200 ); Serial . setDebugOutput ( true ); pinMode ( 4 , INPUT ); Serial . print ( \"ESP32 SDK: \" ); Serial . println ( ESP . getSdkVersion ()); ble . begin ( \"ESP32 BLE Button\" ); Serial . println ( \"Press the button to change the device's name\" ); } void loop () { static uint8_t lastPinState = 1 ; uint8_t pinState = digitalRead ( 4 ); if ( ! pinState && lastPinState ){ onButton (); } lastPinState = pinState ; while ( Serial . available ()) Serial . write ( Serial . read ()); }","title":"SimpleBleDevice"},{"location":"Bluetooth/BLE/#demo","text":"","title":"Demo"},{"location":"Bluetooth/Classic/","text":"Classic Blueooth Basically, the Bluetooth protocol stack is split into two parts: a \u201ccontroller stack\u201d and a \u201chost stack\u201d. The controller stack contains the PHY, Baseband, Link Controller, Link Manager, Device Manager, HCI and other modules, and is used for the hardware interface management and link management. The host stack contains L2CAP, SMP, SDP, ATT, GATT, GAP and various profiles, and functions as an interface to the application layer, thus facilitating the application layer to access the Bluetooth system. The Bluetooth Host can be implemented on the same device as the Controller, or on different devices The link controller operates in three major states: standby, connection and sniff. It enables multiple connections, and other operations, such as inquiry, page, and secure simple-pairing, and therefore enables Piconet and Scatternet. Below are the features: Classic Bluetooth \u2013 Device Discovery (inquiry, and inquiry scan) \u2013 Connection establishment (page, and page scan) \u2013 Multi-connections \u2013 Asynchronous data reception and transmission \u2013 Synchronous links (SCO/eSCO) \u2013 Master/Slave Switch \u2013 Adaptive Frequency Hopping and Channel assessment \u2013 Broadcast encryption \u2013 Authentication and encryption \u2013 Secure Simple-Pairing \u2013 Multi-point and scatternet management \u2013 Sniff mode \u2013 Connectionless Slave Broadcast (transmitter and receiver) \u2013 Enhanced power control \u2013 Ping Example ClassicBletooth.ino 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \"BluetoothSerial.h\" //Header File for Serial Bluetooth BluetoothSerial bt ; //Object for Bluetooth int incoming ; int LED = 2 ; void setup () { Serial . begin ( 115200 ); bt . begin ( \"ESP32_LED_Control\" ); //Name of your Bluetooth Signal Serial . println ( \"Bluetooth Device is Ready to Pair\" ); pinMode ( LED , OUTPUT ); //Specify that LED pin is output } void loop () { if ( bt . available ()) //Check if we receive anything from Bluetooth { incoming = bt . read (); //Read what we recevive Serial . print ( \"Received:\" ); Serial . println ( incoming ); if ( incoming == 49 ) { digitalWrite ( LED , HIGH ); bt . println ( \"LED turned ON\" ); } if ( incoming == 48 ) { digitalWrite ( LED , LOW ); bt . println ( \"LED turned OFF\" ); } } delay ( 20 ); } Android APP link Demo","title":"Bluetooth Classic"},{"location":"Bluetooth/Classic/#classic-blueooth","text":"Basically, the Bluetooth protocol stack is split into two parts: a \u201ccontroller stack\u201d and a \u201chost stack\u201d. The controller stack contains the PHY, Baseband, Link Controller, Link Manager, Device Manager, HCI and other modules, and is used for the hardware interface management and link management. The host stack contains L2CAP, SMP, SDP, ATT, GATT, GAP and various profiles, and functions as an interface to the application layer, thus facilitating the application layer to access the Bluetooth system. The Bluetooth Host can be implemented on the same device as the Controller, or on different devices The link controller operates in three major states: standby, connection and sniff. It enables multiple connections, and other operations, such as inquiry, page, and secure simple-pairing, and therefore enables Piconet and Scatternet. Below are the features:","title":"Classic Blueooth"},{"location":"Bluetooth/Classic/#classic-bluetooth","text":"\u2013 Device Discovery (inquiry, and inquiry scan) \u2013 Connection establishment (page, and page scan) \u2013 Multi-connections \u2013 Asynchronous data reception and transmission \u2013 Synchronous links (SCO/eSCO) \u2013 Master/Slave Switch \u2013 Adaptive Frequency Hopping and Channel assessment \u2013 Broadcast encryption \u2013 Authentication and encryption \u2013 Secure Simple-Pairing \u2013 Multi-point and scatternet management \u2013 Sniff mode \u2013 Connectionless Slave Broadcast (transmitter and receiver) \u2013 Enhanced power control \u2013 Ping","title":"Classic Bluetooth"},{"location":"Bluetooth/Classic/#example","text":"","title":"Example"},{"location":"Bluetooth/Classic/#classicbletoothino","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \"BluetoothSerial.h\" //Header File for Serial Bluetooth BluetoothSerial bt ; //Object for Bluetooth int incoming ; int LED = 2 ; void setup () { Serial . begin ( 115200 ); bt . begin ( \"ESP32_LED_Control\" ); //Name of your Bluetooth Signal Serial . println ( \"Bluetooth Device is Ready to Pair\" ); pinMode ( LED , OUTPUT ); //Specify that LED pin is output } void loop () { if ( bt . available ()) //Check if we receive anything from Bluetooth { incoming = bt . read (); //Read what we recevive Serial . print ( \"Received:\" ); Serial . println ( incoming ); if ( incoming == 49 ) { digitalWrite ( LED , HIGH ); bt . println ( \"LED turned ON\" ); } if ( incoming == 48 ) { digitalWrite ( LED , LOW ); bt . println ( \"LED turned OFF\" ); } } delay ( 20 ); } Android APP link","title":"ClassicBletooth.ino"},{"location":"Bluetooth/Classic/#demo","text":"","title":"Demo"},{"location":"Driver/","text":"CH340 Driver for Windows For manual installation of driver of CH340 USB to serial converter, follow the following steps: Download driver from this link -> Driver Right click on \u2018This PC\u2019 and go to properties. Select Device Manager from the left panel. Expand USB options available Right click on CH340 Select Update driver Select browse option Extract the downloaded folder from the first step. Browse to the extracted folder Follow further instructions of your computer and your CH340 device will be installed.","title":"Driver"},{"location":"Driver/#ch340-driver-for-windows","text":"For manual installation of driver of CH340 USB to serial converter, follow the following steps: Download driver from this link -> Driver Right click on \u2018This PC\u2019 and go to properties. Select Device Manager from the left panel. Expand USB options available Right click on CH340 Select Update driver Select browse option Extract the downloaded folder from the first step. Browse to the extracted folder Follow further instructions of your computer and your CH340 device will be installed.","title":"CH340 Driver for Windows"},{"location":"Encryption/","text":"Encryption AES stands for Advanced Encryption Standard and it is a cryptographic symmetric cipher algorithm that can be used to both encrypt and decrypt information. ince we may want to encrypt data larger than 128 bits, we need to choose a block mode. In our case, we are going to use ECB (Electronic Code Book), which uses the same unaltered key to encrypt each block of plain text. Example Demo to demonstrate to encrypt and decrypt data with AES-128 in ECB mode. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \"mbedtls/aes.h\" void encrypt ( char * plainText , char * key , unsigned char * outputBuffer ){ mbedtls_aes_context aes ; mbedtls_aes_init ( & aes ); mbedtls_aes_setkey_enc ( & aes , ( const unsigned char * ) key , strlen ( key ) * 8 ); mbedtls_aes_crypt_ecb ( & aes , MBEDTLS_AES_ENCRYPT , ( const unsigned char * ) plainText , outputBuffer ); mbedtls_aes_free ( & aes ); } void decrypt ( unsigned char * chipherText , char * key , unsigned char * outputBuffer ){ mbedtls_aes_context aes ; mbedtls_aes_init ( & aes ); mbedtls_aes_setkey_dec ( & aes , ( const unsigned char * ) key , strlen ( key ) * 8 ); mbedtls_aes_crypt_ecb ( & aes , MBEDTLS_AES_DECRYPT , ( const unsigned char * ) chipherText , outputBuffer ); mbedtls_aes_free ( & aes ); } void setup () { Serial . begin ( 115200 ); char * key = \"abcdefghijklmnop\" ; char * plainText = \"MySecret\" ; unsigned char cipherTextOutput [ 16 ]; unsigned char decipheredTextOutput [ 16 ]; encrypt ( plainText , key , cipherTextOutput ); decrypt ( cipherTextOutput , key , decipheredTextOutput ); Serial . println ( \" \\n Original plain text:\" ); Serial . println ( plainText ); Serial . println ( \" \\n Ciphered text:\" ); for ( int i = 0 ; i < 16 ; i ++ ) { char str [ 3 ]; sprintf ( str , \"%02x\" , ( int ) cipherTextOutput [ i ]); Serial . print ( str ); } Serial . println ( \" \\n\\n Deciphered text:\" ); for ( int i = 0 ; i < 16 ; i ++ ) { Serial . print (( char ) decipheredTextOutput [ i ]); } } void loop () {} OUTPUT","title":"Cryptography"},{"location":"Encryption/#encryption","text":"AES stands for Advanced Encryption Standard and it is a cryptographic symmetric cipher algorithm that can be used to both encrypt and decrypt information. ince we may want to encrypt data larger than 128 bits, we need to choose a block mode. In our case, we are going to use ECB (Electronic Code Book), which uses the same unaltered key to encrypt each block of plain text.","title":"Encryption"},{"location":"Encryption/#example","text":"Demo to demonstrate to encrypt and decrypt data with AES-128 in ECB mode. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \"mbedtls/aes.h\" void encrypt ( char * plainText , char * key , unsigned char * outputBuffer ){ mbedtls_aes_context aes ; mbedtls_aes_init ( & aes ); mbedtls_aes_setkey_enc ( & aes , ( const unsigned char * ) key , strlen ( key ) * 8 ); mbedtls_aes_crypt_ecb ( & aes , MBEDTLS_AES_ENCRYPT , ( const unsigned char * ) plainText , outputBuffer ); mbedtls_aes_free ( & aes ); } void decrypt ( unsigned char * chipherText , char * key , unsigned char * outputBuffer ){ mbedtls_aes_context aes ; mbedtls_aes_init ( & aes ); mbedtls_aes_setkey_dec ( & aes , ( const unsigned char * ) key , strlen ( key ) * 8 ); mbedtls_aes_crypt_ecb ( & aes , MBEDTLS_AES_DECRYPT , ( const unsigned char * ) chipherText , outputBuffer ); mbedtls_aes_free ( & aes ); } void setup () { Serial . begin ( 115200 ); char * key = \"abcdefghijklmnop\" ; char * plainText = \"MySecret\" ; unsigned char cipherTextOutput [ 16 ]; unsigned char decipheredTextOutput [ 16 ]; encrypt ( plainText , key , cipherTextOutput ); decrypt ( cipherTextOutput , key , decipheredTextOutput ); Serial . println ( \" \\n Original plain text:\" ); Serial . println ( plainText ); Serial . println ( \" \\n Ciphered text:\" ); for ( int i = 0 ; i < 16 ; i ++ ) { char str [ 3 ]; sprintf ( str , \"%02x\" , ( int ) cipherTextOutput [ i ]); Serial . print ( str ); } Serial . println ( \" \\n\\n Deciphered text:\" ); for ( int i = 0 ; i < 16 ; i ++ ) { Serial . print (( char ) decipheredTextOutput [ i ]); } } void loop () {}","title":"Example"},{"location":"Encryption/#output","text":"","title":"OUTPUT"},{"location":"Examples/WebServer_plotting_Graph_of_TempPresHumAlt/","text":"Webserver for plotting realtime graph Dependent Library https://github.com/adafruit/Adafruit_Sensor https://github.com/adafruit/Adafruit_BME280_Library.git Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 //Edited by Shivam Kumar (eMail: 2016ucs0022@iitjammu.ac.in) from the original \"WebServer_HTTP_graph\" /* * This code serves the realtime graph and values of * temperature, pressure, humidity and altitude through * a web server. */ #include <WiFi.h> #include <WiFiClient.h> #include <WebServer.h> #include <ESPmDNS.h> #include <Arduino.h> #include <Adafruit_Sensor.h> #include <Adafruit_BME280.h> Adafruit_BME280 bme ; float currTemp , currPres , currHum , currAlt ; float avgTemp , avgPres , avgHum , avgAlt ; int numObs = 0 ; //number of observations till now #define SEALEVELPRESSURE_HPA (1013.25) const int valCount = 9 ; float neg = - 300 ; //a big negative number float posi = 1000000.0 ; //a big positive number float tempr [ valCount ]; float prssr [ valCount ]; float humid [ valCount ]; float altit [ valCount ]; int tempPos = - 1 ; int presPos = - 1 ; int humPos = - 1 ; int altPos = - 1 ; float minTemp = posi , minPres = posi , minHum = posi , minAlt = posi ; float maxTemp = neg , maxPres = neg , maxHum = neg , maxAlt = neg ; const char * ssid = \"sincgrid\" ; const char * password = \"sincgrid.com\" ; WebServer server ( 80 ); const int led = 2 ; void handleRoot () { digitalWrite ( led , 1 ); char temp [ 2500 ]; int sec = millis () / 1000 ; int min = sec / 60 ; int hr = min / 60 ; currTemp = bme . readTemperature (); currHum = bme . readHumidity (); currPres = bme . readPressure () / 100.0F ; currAlt = bme . readAltitude ( SEALEVELPRESSURE_HPA ); avgTemp = float ((( avgTemp * numObs ) + currTemp ) / float ( numObs + 1 )); avgPres = float ((( avgPres * numObs ) + currPres ) / float ( numObs + 1 )); avgHum = float ((( avgHum * numObs ) + currHum ) / float ( numObs + 1 )); avgAlt = float ((( avgAlt * numObs ) + currAlt ) / float ( numObs + 1 )); numObs ++ ; minTemp = ( currTemp < minTemp ) ? ( currTemp ) : ( minTemp ); minPres = ( currPres < minPres ) ? ( currPres ) : ( minPres ); minHum = ( currHum < minHum ) ? ( currHum ) : ( minHum ); minAlt = ( currAlt < minAlt ) ? ( currAlt ) : ( minAlt ); maxTemp = ( currTemp > maxTemp ) ? ( currTemp ) : ( maxTemp ); maxPres = ( currPres > maxPres ) ? ( currPres ) : ( maxPres ); maxHum = ( currHum > maxHum ) ? ( currHum ) : ( maxHum ); maxAlt = ( currAlt > maxAlt ) ? ( currAlt ) : ( maxAlt ); String tempSvg = drawTempGraph (); String presSvg = drawPresGraph (); String humSvg = drawHumGraph (); String altSvg = drawAltGraph (); String finalHtml = \"\" ; snprintf ( temp , 2500 , \"<html>\\ <head>\\ <meta http-equiv='refresh' content='5'/>\\ <title>IoT-A-Sync Sensors Output</title>\\ <style>\\ body { background-color: #c7fff7; font-family: Arial, Helvetica, Sans-Serif; Color: #070f27; }\\ h1 {text-align:center;}\\ p {text-align:center;}\\ .divClass {margin: 10px; padding: 15px;}\\ .img {border-width: 1px; border-style: solid;}\\ .innerDiv {display: inline-block; max-height: 250px; max-width: 37.5%%; margin: 10px; padding: 10px;}\\ .clearfix {clear: both;}\\ </style>\\ </head>\\ <body>\\ <h1>Real-Time Remote Monitoring</h1>\\ <p>\\ <b>Uptime:</b> %02d Hrs %02d Mins %02d Secs\\ <br>\\ <b>Location:</b> IIT Jammu\\ </p>\\ \\ <div class= \\\" divClass \\\" >\\ <h2> Temperature </h2>\\ \" , hr , min % 60 , sec % 60 ); finalHtml += temp ; finalHtml += tempSvg ; snprintf ( temp , 2500 , \"<div class= \\\" innerDiv \\\" >\\ <b>Current Temperature:</b> %.2f<sup>o</sup> C\\ <br>\\ <b>Average Temperature for uptime:</b> %.2f<sup>o</sup> C\\ <br>\\ <b>Maximum Temperature for uptime:</b> %.2f<sup>o</sup> C\\ <br>\\ <b>Minimum Temperature for uptime:</b> %.2f<sup>o</sup> C\\ <br>\\ <br>\\ <u>Limits</u>: -45.0<sup>o</sup> C to 105.0<sup>o</sup> C\\ </div>\\ </div>\\ <div class= \\\" clearfix \\\" ></div>\\ <div class= \\\" divClass \\\" >\\ <h2> Pressure </h2>\\ \" , currTemp , avgTemp , maxTemp , minTemp ); finalHtml += temp ; finalHtml += presSvg ; snprintf ( temp , 2500 , \"<div class= \\\" innerDiv \\\" >\\ <b>Current Pressure:</b> %.2f hPa\\ <br>\\ <b>Average Pressure for uptime:</b> %.2f hPa\\ <br>\\ <b>Maximum Pressure for uptime:</b> %.2f hPa\\ <br>\\ <b>Minimum Pressure for uptime:</b> %.2f hPa\\ <br>\\ <br>\\ <u>Limits</u>: 300 hPa to 1100 hPa\\ </div>\\ </div>\\ <div class= \\\" clearfix \\\" ></div>\\ <div class= \\\" divClass \\\" >\\ <h2> Humidity </h2>\\ \" , currPres , avgPres , maxPres , minPres ); finalHtml += temp ; finalHtml += humSvg ; snprintf ( temp , 2500 , \"<div class= \\\" innerDiv \\\" >\\ <b>Current Humidity:</b> %.2f%%\\ <br>\\ <b>Average Humidity for uptime:</b> %.2f%%\\ <br>\\ <b>Maximum Humidity for uptime:</b> %.2f%%\\ <br>\\ <b>Minimum Humidity for uptime:</b> %.2f%%\\ <br>\\ <br>\\ <u>Limits</u>: 0%% to 100%%\\ </div>\\ </div>\\ <div class= \\\" clearfix \\\" ></div>\\ <div class= \\\" divClass \\\" >\\ <h2> Altitude </h2>\\ \" , currHum , avgHum , maxHum , minHum ); finalHtml += temp ; finalHtml += altSvg ; snprintf ( temp , 2500 , \"<div class= \\\" innerDiv \\\" >\\ <b>Current Altitude:</b> %.2f m\\ <br>\\ <b>Average Altitude for uptime:</b> %.2f m\\ <br>\\ <b>Maximum Altitude for uptime:</b> %.2f m\\ <br>\\ <b>Minimum Altitude for uptime:</b> %.2f m\\ <br>\\ <br>\\ <u>Limits</u>: 0 m to 2000 m\\ </div>\\ </div>\\ <div class= \\\" clearfix \\\" ></div>\\ \\ </body>\\ </html>\" , currAlt , avgAlt , maxAlt , minAlt ); finalHtml += temp ; server . send ( 200 , \"text/html\" , finalHtml ); digitalWrite ( led , 0 ); } String drawTempGraph () { if ( tempPos < valCount - 1 ){ tempr [ tempPos + 1 ] = currTemp ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; out += \"<line x1= \\\" 0 \\\" y1= \\\" 175 \\\" x2= \\\" 700 \\\" y2= \\\" 175 \\\" stroke-width= \\\" 3 \\\" />\" ; char temp [ 100 ]; int x = 30 ; for ( int i = 0 ; i <= tempPos ; i ++ ){ sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 525 - 5 * tempr [ i ]) / 3.0 , x + 80 , ( 525 - 5 * tempr [ i + 1 ]) / 3.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 525 - 5 * tempr [ i ]) / 3.0 , 2 ); out += temp ; x += 80 ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 525 - 5 * tempr [ tempPos + 1 ]) / 3.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; tempPos ++ ; // server.send(200, \"image/svg+xml\", out); return out ; } else { for ( int i = 0 ; i < valCount - 1 ; i ++ ){ tempr [ i ] = tempr [ i + 1 ]; } tempr [ valCount - 1 ] = currTemp ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; out += \"<line x1= \\\" 0 \\\" y1= \\\" 175 \\\" x2= \\\" 700 \\\" y2= \\\" 175 \\\" stroke-width= \\\" 3 \\\" />\" ; char temp [ 100 ]; for ( int x = 30 ; x < 670 ; x += 80 ) { sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 525 - 5 * tempr [( x - 30 ) / 80 ]) / 3.0 , x + 80 , ( 525 - 5 * tempr [( x - 30 ) / 80 + 1 ]) / 3.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 525 - 5 * tempr [( x - 30 ) / 80 ]) / 3.0 , 2 ); out += temp ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , 670 , ( 525 - 5 * tempr [ valCount - 1 ]) / 3.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; // server.send(200, \"image/svg+xml\", out); return out ; } } String drawPresGraph (){ if ( presPos < valCount - 1 ){ prssr [ presPos + 1 ] = currPres ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; int x = 30 ; for ( int i = 0 ; i <= presPos ; i ++ ){ sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 5500 - 5 * prssr [ i ]) / 16.0 , x + 80 , ( 5500 - 5 * prssr [ i + 1 ]) / 16.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 5500 - 5 * prssr [ i ]) / 16.0 , 2 ); out += temp ; x += 80 ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 5500 - 5 * prssr [ presPos + 1 ]) / 16.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; presPos ++ ; // server.send(200, \"image/svg+xml\", out); return out ; } else { for ( int i = 0 ; i < valCount - 1 ; i ++ ){ prssr [ i ] = prssr [ i + 1 ]; } prssr [ valCount - 1 ] = currPres ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; for ( int x = 30 ; x < 670 ; x += 80 ) { sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 5500 - 5 * prssr [( x - 30 ) / 80 ]) / 16.0 , x + 80 , ( 5500 - 5 * prssr [( x - 30 ) / 80 + 1 ]) / 16.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 5500 - 5 * prssr [( x - 30 ) / 80 ]) / 16.0 , 2 ); out += temp ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , 670 , ( 5500 - 5 * prssr [ valCount - 1 ]) / 16.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; // server.send(200, \"image/svg+xml\", out); return out ; } } String drawHumGraph (){ if ( humPos < valCount - 1 ){ humid [ humPos + 1 ] = currHum ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; int x = 30 ; for ( int i = 0 ; i <= humPos ; i ++ ){ sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 500 - 5 * humid [ i ]) / 2.0 , x + 80 , ( 500 - 5 * humid [ i + 1 ]) / 2.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 500 - 5 * humid [ i ]) / 2.0 , 2 ); out += temp ; x += 80 ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 500 - 5 * humid [ humPos + 1 ]) / 2.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; humPos ++ ; //server.send(200, \"image/svg+xml\", out); return out ; } else { for ( int i = 0 ; i < valCount - 1 ; i ++ ){ humid [ i ] = humid [ i + 1 ]; } humid [ valCount - 1 ] = currHum ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; for ( int x = 30 ; x < 670 ; x += 80 ) { sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 500 - 5 * humid [( x - 30 ) / 80 ]) / 2.0 , x + 80 , ( 500 - 5 * humid [( x - 30 ) / 80 + 1 ]) / 2.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 500 - 5 * humid [( x - 30 ) / 80 ]) / 2.0 , 2 ); out += temp ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , 670 , ( 500 - 5 * humid [ valCount - 1 ]) / 2.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; // server.send(200, \"image/svg+xml\", out); return out ; } } String drawAltGraph (){ if ( altPos < valCount - 1 ){ altit [ altPos + 1 ] = currAlt ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; int x = 30 ; for ( int i = 0 ; i <= altPos ; i ++ ){ sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 2000 - altit [ i ]) / 8.0 , x + 80 , ( 2000 - altit [ i + 1 ]) / 8.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 2000 - altit [ i ]) / 8.0 , 2 ); out += temp ; x += 80 ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 2000 - altit [ altPos + 1 ]) / 8.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; altPos ++ ; // server.send(200, \"image/svg+xml\", out); return out ; } else { for ( int i = 0 ; i < valCount - 1 ; i ++ ){ altit [ i ] = altit [ i + 1 ]; } altit [ valCount - 1 ] = currAlt ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; for ( int x = 30 ; x < 670 ; x += 80 ) { sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 2000 - altit [( x - 30 ) / 80 ]) / 8.0 , x + 80 , ( 2000 - altit [( x - 30 ) / 80 + 1 ]) / 8.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 2000 - altit [( x - 30 ) / 80 ]) / 8.0 , 2 ); out += temp ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , 670 , ( 2000 - altit [ valCount - 1 ]) / 8.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; // server.send(200, \"image/svg+xml\", out); return out ; } } void handleNotFound () { digitalWrite ( led , 1 ); String message = \"File Not Found \\n\\n \" ; message += \"URI: \" ; message += server . uri (); message += \" \\n Method: \" ; message += ( server . method () == HTTP_GET ) ? \"GET\" : \"POST\" ; message += \" \\n Arguments: \" ; message += server . args (); message += \" \\n \" ; for ( uint8_t i = 0 ; i < server . args (); i ++ ) { message += \" \" + server . argName ( i ) + \": \" + server . arg ( i ) + \" \\n \" ; } server . send ( 404 , \"text/plain\" , message ); digitalWrite ( led , 0 ); } void setup ( void ) { for ( int i = 0 ; i < valCount ; i ++ ){ tempr [ i ] = neg ; prssr [ i ] = neg ; humid [ i ] = neg ; altit [ i ] = neg ; } avgTemp = tempr [ 0 ]; avgPres = prssr [ 0 ]; avgHum = humid [ 0 ]; avgAlt = altit [ 0 ]; bme . begin ( 0x76 ); pinMode ( led , OUTPUT ); digitalWrite ( led , 0 ); Serial . begin ( 115200 ); WiFi . mode ( WIFI_STA ); WiFi . begin ( ssid , password ); Serial . println ( \"\" ); // Wait for connection while ( WiFi . status () != WL_CONNECTED ) { delay ( 500 ); Serial . print ( \".\" ); } Serial . println ( \"\" ); Serial . print ( \"Connected to \" ); Serial . println ( ssid ); Serial . print ( \"IP address: \" ); Serial . println ( WiFi . localIP ()); if ( MDNS . begin ( \"esp32\" )) { Serial . println ( \"MDNS responder started\" ); } server . on ( \"/\" , handleRoot ); /* server.on(\"/temperature.svg\", drawTempGraph); server.on(\"/pressure.svg\", drawPresGraph); server.on(\"/humidity.svg\", drawHumGraph); server.on(\"/altitude.svg\", drawAltGraph); */ /*server.on(\"/inline\", []() { server.send(200, \"text/plain\", \"this works as well\"); });*/ server . onNotFound ( handleNotFound ); server . begin (); Serial . println ( \"HTTP server started\" ); } void loop ( void ) { server . handleClient (); } Credits :- Shivam Kumar","title":"Webserver for plotting realtime graph"},{"location":"Examples/WebServer_plotting_Graph_of_TempPresHumAlt/#webserver-for-plotting-realtime-graph","text":"","title":"Webserver for plotting realtime graph"},{"location":"Examples/WebServer_plotting_Graph_of_TempPresHumAlt/#dependent-library","text":"https://github.com/adafruit/Adafruit_Sensor https://github.com/adafruit/Adafruit_BME280_Library.git","title":"Dependent Library"},{"location":"Examples/WebServer_plotting_Graph_of_TempPresHumAlt/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 //Edited by Shivam Kumar (eMail: 2016ucs0022@iitjammu.ac.in) from the original \"WebServer_HTTP_graph\" /* * This code serves the realtime graph and values of * temperature, pressure, humidity and altitude through * a web server. */ #include <WiFi.h> #include <WiFiClient.h> #include <WebServer.h> #include <ESPmDNS.h> #include <Arduino.h> #include <Adafruit_Sensor.h> #include <Adafruit_BME280.h> Adafruit_BME280 bme ; float currTemp , currPres , currHum , currAlt ; float avgTemp , avgPres , avgHum , avgAlt ; int numObs = 0 ; //number of observations till now #define SEALEVELPRESSURE_HPA (1013.25) const int valCount = 9 ; float neg = - 300 ; //a big negative number float posi = 1000000.0 ; //a big positive number float tempr [ valCount ]; float prssr [ valCount ]; float humid [ valCount ]; float altit [ valCount ]; int tempPos = - 1 ; int presPos = - 1 ; int humPos = - 1 ; int altPos = - 1 ; float minTemp = posi , minPres = posi , minHum = posi , minAlt = posi ; float maxTemp = neg , maxPres = neg , maxHum = neg , maxAlt = neg ; const char * ssid = \"sincgrid\" ; const char * password = \"sincgrid.com\" ; WebServer server ( 80 ); const int led = 2 ; void handleRoot () { digitalWrite ( led , 1 ); char temp [ 2500 ]; int sec = millis () / 1000 ; int min = sec / 60 ; int hr = min / 60 ; currTemp = bme . readTemperature (); currHum = bme . readHumidity (); currPres = bme . readPressure () / 100.0F ; currAlt = bme . readAltitude ( SEALEVELPRESSURE_HPA ); avgTemp = float ((( avgTemp * numObs ) + currTemp ) / float ( numObs + 1 )); avgPres = float ((( avgPres * numObs ) + currPres ) / float ( numObs + 1 )); avgHum = float ((( avgHum * numObs ) + currHum ) / float ( numObs + 1 )); avgAlt = float ((( avgAlt * numObs ) + currAlt ) / float ( numObs + 1 )); numObs ++ ; minTemp = ( currTemp < minTemp ) ? ( currTemp ) : ( minTemp ); minPres = ( currPres < minPres ) ? ( currPres ) : ( minPres ); minHum = ( currHum < minHum ) ? ( currHum ) : ( minHum ); minAlt = ( currAlt < minAlt ) ? ( currAlt ) : ( minAlt ); maxTemp = ( currTemp > maxTemp ) ? ( currTemp ) : ( maxTemp ); maxPres = ( currPres > maxPres ) ? ( currPres ) : ( maxPres ); maxHum = ( currHum > maxHum ) ? ( currHum ) : ( maxHum ); maxAlt = ( currAlt > maxAlt ) ? ( currAlt ) : ( maxAlt ); String tempSvg = drawTempGraph (); String presSvg = drawPresGraph (); String humSvg = drawHumGraph (); String altSvg = drawAltGraph (); String finalHtml = \"\" ; snprintf ( temp , 2500 , \"<html>\\ <head>\\ <meta http-equiv='refresh' content='5'/>\\ <title>IoT-A-Sync Sensors Output</title>\\ <style>\\ body { background-color: #c7fff7; font-family: Arial, Helvetica, Sans-Serif; Color: #070f27; }\\ h1 {text-align:center;}\\ p {text-align:center;}\\ .divClass {margin: 10px; padding: 15px;}\\ .img {border-width: 1px; border-style: solid;}\\ .innerDiv {display: inline-block; max-height: 250px; max-width: 37.5%%; margin: 10px; padding: 10px;}\\ .clearfix {clear: both;}\\ </style>\\ </head>\\ <body>\\ <h1>Real-Time Remote Monitoring</h1>\\ <p>\\ <b>Uptime:</b> %02d Hrs %02d Mins %02d Secs\\ <br>\\ <b>Location:</b> IIT Jammu\\ </p>\\ \\ <div class= \\\" divClass \\\" >\\ <h2> Temperature </h2>\\ \" , hr , min % 60 , sec % 60 ); finalHtml += temp ; finalHtml += tempSvg ; snprintf ( temp , 2500 , \"<div class= \\\" innerDiv \\\" >\\ <b>Current Temperature:</b> %.2f<sup>o</sup> C\\ <br>\\ <b>Average Temperature for uptime:</b> %.2f<sup>o</sup> C\\ <br>\\ <b>Maximum Temperature for uptime:</b> %.2f<sup>o</sup> C\\ <br>\\ <b>Minimum Temperature for uptime:</b> %.2f<sup>o</sup> C\\ <br>\\ <br>\\ <u>Limits</u>: -45.0<sup>o</sup> C to 105.0<sup>o</sup> C\\ </div>\\ </div>\\ <div class= \\\" clearfix \\\" ></div>\\ <div class= \\\" divClass \\\" >\\ <h2> Pressure </h2>\\ \" , currTemp , avgTemp , maxTemp , minTemp ); finalHtml += temp ; finalHtml += presSvg ; snprintf ( temp , 2500 , \"<div class= \\\" innerDiv \\\" >\\ <b>Current Pressure:</b> %.2f hPa\\ <br>\\ <b>Average Pressure for uptime:</b> %.2f hPa\\ <br>\\ <b>Maximum Pressure for uptime:</b> %.2f hPa\\ <br>\\ <b>Minimum Pressure for uptime:</b> %.2f hPa\\ <br>\\ <br>\\ <u>Limits</u>: 300 hPa to 1100 hPa\\ </div>\\ </div>\\ <div class= \\\" clearfix \\\" ></div>\\ <div class= \\\" divClass \\\" >\\ <h2> Humidity </h2>\\ \" , currPres , avgPres , maxPres , minPres ); finalHtml += temp ; finalHtml += humSvg ; snprintf ( temp , 2500 , \"<div class= \\\" innerDiv \\\" >\\ <b>Current Humidity:</b> %.2f%%\\ <br>\\ <b>Average Humidity for uptime:</b> %.2f%%\\ <br>\\ <b>Maximum Humidity for uptime:</b> %.2f%%\\ <br>\\ <b>Minimum Humidity for uptime:</b> %.2f%%\\ <br>\\ <br>\\ <u>Limits</u>: 0%% to 100%%\\ </div>\\ </div>\\ <div class= \\\" clearfix \\\" ></div>\\ <div class= \\\" divClass \\\" >\\ <h2> Altitude </h2>\\ \" , currHum , avgHum , maxHum , minHum ); finalHtml += temp ; finalHtml += altSvg ; snprintf ( temp , 2500 , \"<div class= \\\" innerDiv \\\" >\\ <b>Current Altitude:</b> %.2f m\\ <br>\\ <b>Average Altitude for uptime:</b> %.2f m\\ <br>\\ <b>Maximum Altitude for uptime:</b> %.2f m\\ <br>\\ <b>Minimum Altitude for uptime:</b> %.2f m\\ <br>\\ <br>\\ <u>Limits</u>: 0 m to 2000 m\\ </div>\\ </div>\\ <div class= \\\" clearfix \\\" ></div>\\ \\ </body>\\ </html>\" , currAlt , avgAlt , maxAlt , minAlt ); finalHtml += temp ; server . send ( 200 , \"text/html\" , finalHtml ); digitalWrite ( led , 0 ); } String drawTempGraph () { if ( tempPos < valCount - 1 ){ tempr [ tempPos + 1 ] = currTemp ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; out += \"<line x1= \\\" 0 \\\" y1= \\\" 175 \\\" x2= \\\" 700 \\\" y2= \\\" 175 \\\" stroke-width= \\\" 3 \\\" />\" ; char temp [ 100 ]; int x = 30 ; for ( int i = 0 ; i <= tempPos ; i ++ ){ sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 525 - 5 * tempr [ i ]) / 3.0 , x + 80 , ( 525 - 5 * tempr [ i + 1 ]) / 3.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 525 - 5 * tempr [ i ]) / 3.0 , 2 ); out += temp ; x += 80 ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 525 - 5 * tempr [ tempPos + 1 ]) / 3.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; tempPos ++ ; // server.send(200, \"image/svg+xml\", out); return out ; } else { for ( int i = 0 ; i < valCount - 1 ; i ++ ){ tempr [ i ] = tempr [ i + 1 ]; } tempr [ valCount - 1 ] = currTemp ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; out += \"<line x1= \\\" 0 \\\" y1= \\\" 175 \\\" x2= \\\" 700 \\\" y2= \\\" 175 \\\" stroke-width= \\\" 3 \\\" />\" ; char temp [ 100 ]; for ( int x = 30 ; x < 670 ; x += 80 ) { sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 525 - 5 * tempr [( x - 30 ) / 80 ]) / 3.0 , x + 80 , ( 525 - 5 * tempr [( x - 30 ) / 80 + 1 ]) / 3.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 525 - 5 * tempr [( x - 30 ) / 80 ]) / 3.0 , 2 ); out += temp ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , 670 , ( 525 - 5 * tempr [ valCount - 1 ]) / 3.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; // server.send(200, \"image/svg+xml\", out); return out ; } } String drawPresGraph (){ if ( presPos < valCount - 1 ){ prssr [ presPos + 1 ] = currPres ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; int x = 30 ; for ( int i = 0 ; i <= presPos ; i ++ ){ sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 5500 - 5 * prssr [ i ]) / 16.0 , x + 80 , ( 5500 - 5 * prssr [ i + 1 ]) / 16.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 5500 - 5 * prssr [ i ]) / 16.0 , 2 ); out += temp ; x += 80 ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 5500 - 5 * prssr [ presPos + 1 ]) / 16.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; presPos ++ ; // server.send(200, \"image/svg+xml\", out); return out ; } else { for ( int i = 0 ; i < valCount - 1 ; i ++ ){ prssr [ i ] = prssr [ i + 1 ]; } prssr [ valCount - 1 ] = currPres ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; for ( int x = 30 ; x < 670 ; x += 80 ) { sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 5500 - 5 * prssr [( x - 30 ) / 80 ]) / 16.0 , x + 80 , ( 5500 - 5 * prssr [( x - 30 ) / 80 + 1 ]) / 16.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 5500 - 5 * prssr [( x - 30 ) / 80 ]) / 16.0 , 2 ); out += temp ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , 670 , ( 5500 - 5 * prssr [ valCount - 1 ]) / 16.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; // server.send(200, \"image/svg+xml\", out); return out ; } } String drawHumGraph (){ if ( humPos < valCount - 1 ){ humid [ humPos + 1 ] = currHum ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; int x = 30 ; for ( int i = 0 ; i <= humPos ; i ++ ){ sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 500 - 5 * humid [ i ]) / 2.0 , x + 80 , ( 500 - 5 * humid [ i + 1 ]) / 2.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 500 - 5 * humid [ i ]) / 2.0 , 2 ); out += temp ; x += 80 ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 500 - 5 * humid [ humPos + 1 ]) / 2.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; humPos ++ ; //server.send(200, \"image/svg+xml\", out); return out ; } else { for ( int i = 0 ; i < valCount - 1 ; i ++ ){ humid [ i ] = humid [ i + 1 ]; } humid [ valCount - 1 ] = currHum ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; for ( int x = 30 ; x < 670 ; x += 80 ) { sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 500 - 5 * humid [( x - 30 ) / 80 ]) / 2.0 , x + 80 , ( 500 - 5 * humid [( x - 30 ) / 80 + 1 ]) / 2.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 500 - 5 * humid [( x - 30 ) / 80 ]) / 2.0 , 2 ); out += temp ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , 670 , ( 500 - 5 * humid [ valCount - 1 ]) / 2.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; // server.send(200, \"image/svg+xml\", out); return out ; } } String drawAltGraph (){ if ( altPos < valCount - 1 ){ altit [ altPos + 1 ] = currAlt ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; int x = 30 ; for ( int i = 0 ; i <= altPos ; i ++ ){ sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 2000 - altit [ i ]) / 8.0 , x + 80 , ( 2000 - altit [ i + 1 ]) / 8.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 2000 - altit [ i ]) / 8.0 , 2 ); out += temp ; x += 80 ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 2000 - altit [ altPos + 1 ]) / 8.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; altPos ++ ; // server.send(200, \"image/svg+xml\", out); return out ; } else { for ( int i = 0 ; i < valCount - 1 ; i ++ ){ altit [ i ] = altit [ i + 1 ]; } altit [ valCount - 1 ] = currAlt ; String out = \"\" ; out += \"<svg xmlns= \\\" http://www.w3.org/2000/svg \\\" version= \\\" 1.1 \\\" width= \\\" 700 \\\" height= \\\" 250 \\\" class= \\\" img \\\" > \\n \" ; out += \"<rect width= \\\" 700 \\\" height= \\\" 250 \\\" fill= \\\" rgb(250, 230, 210) \\\" stroke-width= \\\" 1 \\\" stroke= \\\" rgb(0, 0, 0) \\\" /> \\n \" ; out += \"<g stroke= \\\" black \\\" > \\n \" ; char temp [ 100 ]; for ( int x = 30 ; x < 670 ; x += 80 ) { sprintf ( temp , \"<line x1= \\\" %d \\\" y1= \\\" %f \\\" x2= \\\" %d \\\" y2= \\\" %f \\\" stroke-width= \\\" 1 \\\" /> \\n \" , x , ( 2000 - altit [( x - 30 ) / 80 ]) / 8.0 , x + 80 , ( 2000 - altit [( x - 30 ) / 80 + 1 ]) / 8.0 ); out += temp ; sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , x , ( 2000 - altit [( x - 30 ) / 80 ]) / 8.0 , 2 ); out += temp ; } sprintf ( temp , \"<circle cx= \\\" %d \\\" cy= \\\" %f \\\" r= \\\" %d \\\" stroke= \\\" black \\\" stroke-width= \\\" 1 \\\" fill= \\\" red \\\" />\" , 670 , ( 2000 - altit [ valCount - 1 ]) / 8.0 , 2 ); out += temp ; out += \"</g> \\n </svg> \\n \" ; // server.send(200, \"image/svg+xml\", out); return out ; } } void handleNotFound () { digitalWrite ( led , 1 ); String message = \"File Not Found \\n\\n \" ; message += \"URI: \" ; message += server . uri (); message += \" \\n Method: \" ; message += ( server . method () == HTTP_GET ) ? \"GET\" : \"POST\" ; message += \" \\n Arguments: \" ; message += server . args (); message += \" \\n \" ; for ( uint8_t i = 0 ; i < server . args (); i ++ ) { message += \" \" + server . argName ( i ) + \": \" + server . arg ( i ) + \" \\n \" ; } server . send ( 404 , \"text/plain\" , message ); digitalWrite ( led , 0 ); } void setup ( void ) { for ( int i = 0 ; i < valCount ; i ++ ){ tempr [ i ] = neg ; prssr [ i ] = neg ; humid [ i ] = neg ; altit [ i ] = neg ; } avgTemp = tempr [ 0 ]; avgPres = prssr [ 0 ]; avgHum = humid [ 0 ]; avgAlt = altit [ 0 ]; bme . begin ( 0x76 ); pinMode ( led , OUTPUT ); digitalWrite ( led , 0 ); Serial . begin ( 115200 ); WiFi . mode ( WIFI_STA ); WiFi . begin ( ssid , password ); Serial . println ( \"\" ); // Wait for connection while ( WiFi . status () != WL_CONNECTED ) { delay ( 500 ); Serial . print ( \".\" ); } Serial . println ( \"\" ); Serial . print ( \"Connected to \" ); Serial . println ( ssid ); Serial . print ( \"IP address: \" ); Serial . println ( WiFi . localIP ()); if ( MDNS . begin ( \"esp32\" )) { Serial . println ( \"MDNS responder started\" ); } server . on ( \"/\" , handleRoot ); /* server.on(\"/temperature.svg\", drawTempGraph); server.on(\"/pressure.svg\", drawPresGraph); server.on(\"/humidity.svg\", drawHumGraph); server.on(\"/altitude.svg\", drawAltGraph); */ /*server.on(\"/inline\", []() { server.send(200, \"text/plain\", \"this works as well\"); });*/ server . onNotFound ( handleNotFound ); server . begin (); Serial . println ( \"HTTP server started\" ); } void loop ( void ) { server . handleClient (); }","title":"Code"},{"location":"Examples/WebServer_plotting_Graph_of_TempPresHumAlt/#credits-shivam-kumar","text":"","title":"Credits :- Shivam Kumar"},{"location":"Examples/examples/","text":"","title":"Examples"},{"location":"Examples/OnBoard_Peripheral/Blink_Led/","text":"Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define LED_BUILTIN 2 // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second }","title":"Blink Led"},{"location":"Examples/OnBoard_Peripheral/Blink_Led/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define LED_BUILTIN 2 // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second }","title":"Code"},{"location":"Examples/OnBoard_Peripheral/IR_Reciever/","text":"IR Reciever platformio.ini 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ;PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32dev] platform = espressif32 framework = arduino board = esp32dev board_build.f_cpu = 160000000L board_build.f_flash = 80000000L board_build.flash_mode = qio build_flags = -DWEBSOCKET_DISABLED = true lib_deps = ArduinoJson@~5.13.4 https://github.com/mcci-catena/arduino-lmic.git https://github.com/z3t0/Arduino-IRremote.git monitor_speed = 115200 monitor_port = ${common.port} upload_speed = 921600 upload_port = ${common.port} ;;; uncomment above line, and comment next line to use uploading via com port ; upload_port=192.168.43.221 [common] port = COM9 main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 #include <Arduino.h> #include \"Modules/modules.h\" //------------------------------------------------------------------------------ // Include the IRremote library header // #include <IRremote.h> #define LED_BUILTIN 2 //------------------------------------------------------------------------------ // Tell IRremote which Arduino pin is connected to the IR Receiver (TSOP4838) // #if defined(ESP32) int IR_RECEIVE_PIN = 15 ; #else int IR_RECEIVE_PIN = 11 ; #endif IRrecv irrecv ( IR_RECEIVE_PIN ); //+============================================================================= // Configure the Arduino // void setup () { pinMode ( LED_BUILTIN , OUTPUT ); Serial . begin ( 115200 ); // Status message will be sent to PC at 9600 baud #if defined(__AVR_ATmega32U4__) while ( ! Serial ); //delay for Leonardo, but this loops forever for Maple Serial #endif // Just to know which program is running on my Arduino Serial . println ( F ( \"START \" __FILE__ \" from \" __DATE__ )); irrecv . enableIRIn (); // Start the receiver Serial . print ( F ( \"Ready to receive IR signals at pin \" )); Serial . println ( IR_RECEIVE_PIN ); } //+============================================================================= // Display IR code // void ircode ( decode_results * results ) { // Panasonic has an Address if ( results -> decode_type == PANASONIC ) { Serial . print ( results -> address , HEX ); Serial . print ( \":\" ); } // Print Code Serial . print ( results -> value , HEX ); } //+============================================================================= // Display encoding type // void encoding ( decode_results * results ) { switch ( results -> decode_type ) { default : case UNKNOWN : Serial . print ( \"UNKNOWN\" ); break ; case NEC : Serial . print ( \"NEC\" ); break ; case SONY : Serial . print ( \"SONY\" ); break ; case RC5 : Serial . print ( \"RC5\" ); break ; case RC6 : Serial . print ( \"RC6\" ); break ; case DISH : Serial . print ( \"DISH\" ); break ; case SHARP : Serial . print ( \"SHARP\" ); break ; case SHARP_ALT : Serial . print ( \"SHARP_ALT\" ); break ; case JVC : Serial . print ( \"JVC\" ); break ; case SANYO : Serial . print ( \"SANYO\" ); break ; case MITSUBISHI : Serial . print ( \"MITSUBISHI\" ); break ; case SAMSUNG : Serial . print ( \"SAMSUNG\" ); break ; case LG : Serial . print ( \"LG\" ); break ; case WHYNTER : Serial . print ( \"WHYNTER\" ); break ; case AIWA_RC_T501 : Serial . print ( \"AIWA_RC_T501\" ); break ; case PANASONIC : Serial . print ( \"PANASONIC\" ); break ; case DENON : Serial . print ( \"Denon\" ); break ; case BOSEWAVE : Serial . print ( \"BOSEWAVE\" ); break ; } } //+============================================================================= // Dump out the decode_results structure. // void dumpInfo ( decode_results * results ) { // Check if the buffer overflowed if ( results -> overflow ) { Serial . println ( \"IR code too long. Edit IRremoteInt.h and increase RAW_BUFFER_LENGTH\" ); return ; } // Show Encoding standard Serial . print ( \"Encoding : \" ); encoding ( results ); Serial . println ( \"\" ); // Show Code & length Serial . print ( \"Code : 0x\" ); ircode ( results ); Serial . print ( \" (\" ); Serial . print ( results -> bits , DEC ); Serial . println ( \" bits)\" ); } //+============================================================================= // Dump out the decode_results structure. // void dumpRaw ( decode_results * results ) { // Print Raw data Serial . print ( \"Timing[\" ); Serial . print ( results -> rawlen - 1 , DEC ); Serial . println ( \"]: \" ); for ( unsigned int i = 1 ; i < results -> rawlen ; i ++ ) { unsigned long x = results -> rawbuf [ i ] * MICROS_PER_TICK ; if ( ! ( i & 1 )) { // even Serial . print ( \"-\" ); if ( x < 1000 ) Serial . print ( \" \" ); if ( x < 100 ) Serial . print ( \" \" ); Serial . print ( x , DEC ); } else { // odd Serial . print ( \" \" ); Serial . print ( \"+\" ); if ( x < 1000 ) Serial . print ( \" \" ); if ( x < 100 ) Serial . print ( \" \" ); Serial . print ( x , DEC ); if ( i < results -> rawlen - 1 ) Serial . print ( \", \" ); //',' not needed for last one } if ( ! ( i % 8 )) Serial . println ( \"\" ); } Serial . println ( \"\" ); // Newline } //+============================================================================= // Dump out the decode_results structure. // void dumpCode ( decode_results * results ) { // Start declaration Serial . print ( \"unsigned int \" ); // variable type Serial . print ( \"rawData[\" ); // array name Serial . print ( results -> rawlen - 1 , DEC ); // array size Serial . print ( \"] = {\" ); // Start declaration // Dump data for ( unsigned int i = 1 ; i < results -> rawlen ; i ++ ) { Serial . print ( results -> rawbuf [ i ] * MICROS_PER_TICK , DEC ); if ( i < results -> rawlen - 1 ) Serial . print ( \",\" ); // ',' not needed on last one if ( ! ( i & 1 )) Serial . print ( \" \" ); } // End declaration Serial . print ( \"};\" ); // // Comment Serial . print ( \" // \" ); encoding ( results ); Serial . print ( \" \" ); ircode ( results ); // Newline Serial . println ( \"\" ); // Now dump \"known\" codes if ( results -> decode_type != UNKNOWN ) { // Some protocols have an address if ( results -> decode_type == PANASONIC ) { Serial . print ( \"unsigned int addr = 0x\" ); Serial . print ( results -> address , HEX ); Serial . println ( \";\" ); } // All protocols have data Serial . print ( \"unsigned int data = 0x\" ); Serial . print ( results -> value , HEX ); Serial . println ( \";\" ); } } //+============================================================================= // Dump out the raw data as Pronto Hex. // void dumpPronto ( decode_results * results ) { Serial . print ( \"Pronto Hex: \" ); irrecv . dumpPronto ( Serial , results ); Serial . println (); } //+============================================================================= // The repeating section of the code // void loop () { decode_results results ; // Somewhere to store the results if ( irrecv . decode ( & results )) { // Grab an IR code dumpInfo ( & results ); // Output the results dumpRaw ( & results ); // Output the results in RAW format dumpPronto ( & results ); dumpCode ( & results ); // Output the results as source code Serial . println ( \"\" ); // Blank line between entries irrecv . resume (); // Prepare for the next value } } Git repository link for codes :- Repo","title":"IR Reciever"},{"location":"Examples/OnBoard_Peripheral/IR_Reciever/#ir-reciever","text":"","title":"IR Reciever"},{"location":"Examples/OnBoard_Peripheral/IR_Reciever/#platformioini","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ;PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32dev] platform = espressif32 framework = arduino board = esp32dev board_build.f_cpu = 160000000L board_build.f_flash = 80000000L board_build.flash_mode = qio build_flags = -DWEBSOCKET_DISABLED = true lib_deps = ArduinoJson@~5.13.4 https://github.com/mcci-catena/arduino-lmic.git https://github.com/z3t0/Arduino-IRremote.git monitor_speed = 115200 monitor_port = ${common.port} upload_speed = 921600 upload_port = ${common.port} ;;; uncomment above line, and comment next line to use uploading via com port ; upload_port=192.168.43.221 [common] port = COM9","title":"platformio.ini"},{"location":"Examples/OnBoard_Peripheral/IR_Reciever/#maincpp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 #include <Arduino.h> #include \"Modules/modules.h\" //------------------------------------------------------------------------------ // Include the IRremote library header // #include <IRremote.h> #define LED_BUILTIN 2 //------------------------------------------------------------------------------ // Tell IRremote which Arduino pin is connected to the IR Receiver (TSOP4838) // #if defined(ESP32) int IR_RECEIVE_PIN = 15 ; #else int IR_RECEIVE_PIN = 11 ; #endif IRrecv irrecv ( IR_RECEIVE_PIN ); //+============================================================================= // Configure the Arduino // void setup () { pinMode ( LED_BUILTIN , OUTPUT ); Serial . begin ( 115200 ); // Status message will be sent to PC at 9600 baud #if defined(__AVR_ATmega32U4__) while ( ! Serial ); //delay for Leonardo, but this loops forever for Maple Serial #endif // Just to know which program is running on my Arduino Serial . println ( F ( \"START \" __FILE__ \" from \" __DATE__ )); irrecv . enableIRIn (); // Start the receiver Serial . print ( F ( \"Ready to receive IR signals at pin \" )); Serial . println ( IR_RECEIVE_PIN ); } //+============================================================================= // Display IR code // void ircode ( decode_results * results ) { // Panasonic has an Address if ( results -> decode_type == PANASONIC ) { Serial . print ( results -> address , HEX ); Serial . print ( \":\" ); } // Print Code Serial . print ( results -> value , HEX ); } //+============================================================================= // Display encoding type // void encoding ( decode_results * results ) { switch ( results -> decode_type ) { default : case UNKNOWN : Serial . print ( \"UNKNOWN\" ); break ; case NEC : Serial . print ( \"NEC\" ); break ; case SONY : Serial . print ( \"SONY\" ); break ; case RC5 : Serial . print ( \"RC5\" ); break ; case RC6 : Serial . print ( \"RC6\" ); break ; case DISH : Serial . print ( \"DISH\" ); break ; case SHARP : Serial . print ( \"SHARP\" ); break ; case SHARP_ALT : Serial . print ( \"SHARP_ALT\" ); break ; case JVC : Serial . print ( \"JVC\" ); break ; case SANYO : Serial . print ( \"SANYO\" ); break ; case MITSUBISHI : Serial . print ( \"MITSUBISHI\" ); break ; case SAMSUNG : Serial . print ( \"SAMSUNG\" ); break ; case LG : Serial . print ( \"LG\" ); break ; case WHYNTER : Serial . print ( \"WHYNTER\" ); break ; case AIWA_RC_T501 : Serial . print ( \"AIWA_RC_T501\" ); break ; case PANASONIC : Serial . print ( \"PANASONIC\" ); break ; case DENON : Serial . print ( \"Denon\" ); break ; case BOSEWAVE : Serial . print ( \"BOSEWAVE\" ); break ; } } //+============================================================================= // Dump out the decode_results structure. // void dumpInfo ( decode_results * results ) { // Check if the buffer overflowed if ( results -> overflow ) { Serial . println ( \"IR code too long. Edit IRremoteInt.h and increase RAW_BUFFER_LENGTH\" ); return ; } // Show Encoding standard Serial . print ( \"Encoding : \" ); encoding ( results ); Serial . println ( \"\" ); // Show Code & length Serial . print ( \"Code : 0x\" ); ircode ( results ); Serial . print ( \" (\" ); Serial . print ( results -> bits , DEC ); Serial . println ( \" bits)\" ); } //+============================================================================= // Dump out the decode_results structure. // void dumpRaw ( decode_results * results ) { // Print Raw data Serial . print ( \"Timing[\" ); Serial . print ( results -> rawlen - 1 , DEC ); Serial . println ( \"]: \" ); for ( unsigned int i = 1 ; i < results -> rawlen ; i ++ ) { unsigned long x = results -> rawbuf [ i ] * MICROS_PER_TICK ; if ( ! ( i & 1 )) { // even Serial . print ( \"-\" ); if ( x < 1000 ) Serial . print ( \" \" ); if ( x < 100 ) Serial . print ( \" \" ); Serial . print ( x , DEC ); } else { // odd Serial . print ( \" \" ); Serial . print ( \"+\" ); if ( x < 1000 ) Serial . print ( \" \" ); if ( x < 100 ) Serial . print ( \" \" ); Serial . print ( x , DEC ); if ( i < results -> rawlen - 1 ) Serial . print ( \", \" ); //',' not needed for last one } if ( ! ( i % 8 )) Serial . println ( \"\" ); } Serial . println ( \"\" ); // Newline } //+============================================================================= // Dump out the decode_results structure. // void dumpCode ( decode_results * results ) { // Start declaration Serial . print ( \"unsigned int \" ); // variable type Serial . print ( \"rawData[\" ); // array name Serial . print ( results -> rawlen - 1 , DEC ); // array size Serial . print ( \"] = {\" ); // Start declaration // Dump data for ( unsigned int i = 1 ; i < results -> rawlen ; i ++ ) { Serial . print ( results -> rawbuf [ i ] * MICROS_PER_TICK , DEC ); if ( i < results -> rawlen - 1 ) Serial . print ( \",\" ); // ',' not needed on last one if ( ! ( i & 1 )) Serial . print ( \" \" ); } // End declaration Serial . print ( \"};\" ); // // Comment Serial . print ( \" // \" ); encoding ( results ); Serial . print ( \" \" ); ircode ( results ); // Newline Serial . println ( \"\" ); // Now dump \"known\" codes if ( results -> decode_type != UNKNOWN ) { // Some protocols have an address if ( results -> decode_type == PANASONIC ) { Serial . print ( \"unsigned int addr = 0x\" ); Serial . print ( results -> address , HEX ); Serial . println ( \";\" ); } // All protocols have data Serial . print ( \"unsigned int data = 0x\" ); Serial . print ( results -> value , HEX ); Serial . println ( \";\" ); } } //+============================================================================= // Dump out the raw data as Pronto Hex. // void dumpPronto ( decode_results * results ) { Serial . print ( \"Pronto Hex: \" ); irrecv . dumpPronto ( Serial , results ); Serial . println (); } //+============================================================================= // The repeating section of the code // void loop () { decode_results results ; // Somewhere to store the results if ( irrecv . decode ( & results )) { // Grab an IR code dumpInfo ( & results ); // Output the results dumpRaw ( & results ); // Output the results in RAW format dumpPronto ( & results ); dumpCode ( & results ); // Output the results as source code Serial . println ( \"\" ); // Blank line between entries irrecv . resume (); // Prepare for the next value } } Git repository link for codes :- Repo","title":"main.cpp"},{"location":"FreeRtos/","text":"Basics of FreeRtos What is RTOS? Real Time Operating System, commonly known as an RTOS, is a software component that rapidly switches between tasks, giving the impression that multiple programs are being executed at the same time on a single processing core. Most operating systems appear to allow multiple programs to execute at the same time. This is called multi-tasking. In reality, each processor core can only be running a single thread of execution at any given point in time. A part of the operating system called the scheduler is responsible for deciding which program to run when, and provides the illusion of simultaneous execution by rapidly switching between each program. What is FreeRtos? FreeRTOS is a real-time operating system kernel for embedded devices that has been ported to 35 microcontroller platforms. It is distributed under the MIT License. Code Examples platformio.ini 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ;PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32dev] platform = espressif32 board = esp32dev ; board = esp32doit-devkit-v1 framework = arduino monitor_speed = 115200 ; upload_speed=921000 ; upload_port=COM40 ; monitor_port = COM40 ; upload_port=$common_settings.COM_PORT) ; monitor_port = $(common_settings.COM_PORT) ; debug_tool=esp-prog ; debug_init_break=tbreak setup1 ; upload_protocol = esp-prog ; [env:common_settings] ; COM_PORT=COM40 main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <Arduino.h> #include \"Common.h\" void setup () { // put your setup code here, to run once: Serial . begin ( 115200 ); delay ( 1000 ); // setup_executionCore(); setup_QueuesBetweenTask (); } void loop () { // put your main code here, to run repeatedly: // loop_getExecutionCore(); void loop_QueuesBetweenTask (); } Common.h 1 2 3 4 5 6 7 8 9 10 #ifndef __COMMON_H #define __COMMON_H void taskOne( void * parameter ); void taskTwo( void * parameter); void initiate_create_task_example(); void setup_executionCore(); void loop_getExecutionCore(); void setup_QueuesBetweenTask(); void loop_QueuesBetweenTask(); #endif //__COMMON_H Creating_Tasks.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include <Arduino.h> #include \"Common.h\" void taskOne ( void * parameter ) { for ( int i = 0 ; i < 10 ; i ++ ) { Serial . println ( \"Hello from task 1\" ); delay ( 1000 ); } Serial . println ( \"Ending task 1\" ); vTaskDelete ( NULL ); } void taskTwo ( void * parameter ) { for ( int i = 0 ; i < 10 ; i ++ ) { Serial . println ( \"Hello from task 2\" ); delay ( 1000 ); } Serial . println ( \"Ending task 2\" ); vTaskDelete ( NULL ); } void initiate_create_task_example () { xTaskCreate ( taskOne , /* Task function. */ \"TaskOne\" , /* String with name of task. */ 10000 , /* Stack size in bytes. */ NULL , /* Parameter passed as input of the task */ 1 , /* Priority of the task. */ NULL ); /* Task handle. */ xTaskCreate ( taskTwo , /* Task function. */ \"TaskTwo\" , /* String with name of task. */ 10000 , /* Stack size in bytes. */ NULL , /* Parameter passed as input of the task */ 1 , /* Priority of the task. */ NULL ); /* Task handle. */ } GetExecutionCore.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \"Common.h\" #include <Arduino.h> void genericTask ( void * parameter ) { Serial . print ( \"Created task: Executing on core \" ); Serial . println ( xPortGetCoreID ()); vTaskDelete ( NULL ); } void setup_executionCore () { Serial . print ( \"Setup: Executing on core \" ); Serial . println ( xPortGetCoreID ()); xTaskCreate ( genericTask , /* Task function. */ \"genericTask\" , /* String with name of task. */ 10000 , /* Stack size in words. */ NULL , /* Parameter passed as input of the task */ 2 , /* Priority of the task. */ NULL ); /* Task handle. */ delay ( 2000 ); } void loop_getExecutionCore (){ Serial . print ( \"Main Loop: Executing on core \" ); Serial . println ( xPortGetCoreID ()); delay ( 1000 ); } QueuesBetweenTask.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include <Arduino.h> #include \"Common.h\" QueueHandle_t queue ; int queueSize = 10 ; void producerTask ( void * parameter ) { for ( int i = 0 ; i < queueSize ; i ++ ){ xQueueSend ( queue , & i , portMAX_DELAY ); } vTaskDelete ( NULL ); } void consumerTask ( void * parameter ) { int element ; for ( int i = 0 ; i < queueSize ; i ++ ){ xQueueReceive ( queue , & element , portMAX_DELAY ); Serial . print ( element ); Serial . print ( \"|\" ); } vTaskDelete ( NULL ); } void setup_QueuesBetweenTask () { queue = xQueueCreate ( queueSize , sizeof ( int )); if ( queue == NULL ) { Serial . println ( \"Error creating the queue\" ); } xTaskCreate ( producerTask , /* Task function. */ \"Producer\" , /* String with name of task. */ 10000 , /* Stack size in words. */ NULL , /* Parameter passed as input of the task */ 1 , /* Priority of the task. */ NULL ); /* Task handle. */ xTaskCreate ( consumerTask , /* Task function. */ \"Consumer\" , /* String with name of task. */ 10000 , /* Stack size in words. */ NULL , /* Parameter passed as input of the task */ 1 , /* Priority of the task. */ NULL ); /* Task handle. */ } void loop_QueuesBetweenTask () { delay ( 100000 ); }","title":"FreeRtos basics"},{"location":"FreeRtos/#basics-of-freertos","text":"","title":"Basics of FreeRtos"},{"location":"FreeRtos/#what-is-rtos","text":"Real Time Operating System, commonly known as an RTOS, is a software component that rapidly switches between tasks, giving the impression that multiple programs are being executed at the same time on a single processing core. Most operating systems appear to allow multiple programs to execute at the same time. This is called multi-tasking. In reality, each processor core can only be running a single thread of execution at any given point in time. A part of the operating system called the scheduler is responsible for deciding which program to run when, and provides the illusion of simultaneous execution by rapidly switching between each program.","title":"What is RTOS?"},{"location":"FreeRtos/#what-is-freertos","text":"FreeRTOS is a real-time operating system kernel for embedded devices that has been ported to 35 microcontroller platforms. It is distributed under the MIT License.","title":"What is FreeRtos?"},{"location":"FreeRtos/#code-examples","text":"","title":"Code Examples"},{"location":"FreeRtos/#platformioini","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ;PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32dev] platform = espressif32 board = esp32dev ; board = esp32doit-devkit-v1 framework = arduino monitor_speed = 115200 ; upload_speed=921000 ; upload_port=COM40 ; monitor_port = COM40 ; upload_port=$common_settings.COM_PORT) ; monitor_port = $(common_settings.COM_PORT) ; debug_tool=esp-prog ; debug_init_break=tbreak setup1 ; upload_protocol = esp-prog ; [env:common_settings] ; COM_PORT=COM40","title":"platformio.ini"},{"location":"FreeRtos/#maincpp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <Arduino.h> #include \"Common.h\" void setup () { // put your setup code here, to run once: Serial . begin ( 115200 ); delay ( 1000 ); // setup_executionCore(); setup_QueuesBetweenTask (); } void loop () { // put your main code here, to run repeatedly: // loop_getExecutionCore(); void loop_QueuesBetweenTask (); }","title":"main.cpp"},{"location":"FreeRtos/#commonh","text":"1 2 3 4 5 6 7 8 9 10 #ifndef __COMMON_H #define __COMMON_H void taskOne( void * parameter ); void taskTwo( void * parameter); void initiate_create_task_example(); void setup_executionCore(); void loop_getExecutionCore(); void setup_QueuesBetweenTask(); void loop_QueuesBetweenTask(); #endif //__COMMON_H","title":"Common.h"},{"location":"FreeRtos/#creating_taskscpp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include <Arduino.h> #include \"Common.h\" void taskOne ( void * parameter ) { for ( int i = 0 ; i < 10 ; i ++ ) { Serial . println ( \"Hello from task 1\" ); delay ( 1000 ); } Serial . println ( \"Ending task 1\" ); vTaskDelete ( NULL ); } void taskTwo ( void * parameter ) { for ( int i = 0 ; i < 10 ; i ++ ) { Serial . println ( \"Hello from task 2\" ); delay ( 1000 ); } Serial . println ( \"Ending task 2\" ); vTaskDelete ( NULL ); } void initiate_create_task_example () { xTaskCreate ( taskOne , /* Task function. */ \"TaskOne\" , /* String with name of task. */ 10000 , /* Stack size in bytes. */ NULL , /* Parameter passed as input of the task */ 1 , /* Priority of the task. */ NULL ); /* Task handle. */ xTaskCreate ( taskTwo , /* Task function. */ \"TaskTwo\" , /* String with name of task. */ 10000 , /* Stack size in bytes. */ NULL , /* Parameter passed as input of the task */ 1 , /* Priority of the task. */ NULL ); /* Task handle. */ }","title":"Creating_Tasks.cpp"},{"location":"FreeRtos/#getexecutioncorecpp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \"Common.h\" #include <Arduino.h> void genericTask ( void * parameter ) { Serial . print ( \"Created task: Executing on core \" ); Serial . println ( xPortGetCoreID ()); vTaskDelete ( NULL ); } void setup_executionCore () { Serial . print ( \"Setup: Executing on core \" ); Serial . println ( xPortGetCoreID ()); xTaskCreate ( genericTask , /* Task function. */ \"genericTask\" , /* String with name of task. */ 10000 , /* Stack size in words. */ NULL , /* Parameter passed as input of the task */ 2 , /* Priority of the task. */ NULL ); /* Task handle. */ delay ( 2000 ); } void loop_getExecutionCore (){ Serial . print ( \"Main Loop: Executing on core \" ); Serial . println ( xPortGetCoreID ()); delay ( 1000 ); }","title":"GetExecutionCore.cpp"},{"location":"FreeRtos/#queuesbetweentaskcpp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include <Arduino.h> #include \"Common.h\" QueueHandle_t queue ; int queueSize = 10 ; void producerTask ( void * parameter ) { for ( int i = 0 ; i < queueSize ; i ++ ){ xQueueSend ( queue , & i , portMAX_DELAY ); } vTaskDelete ( NULL ); } void consumerTask ( void * parameter ) { int element ; for ( int i = 0 ; i < queueSize ; i ++ ){ xQueueReceive ( queue , & element , portMAX_DELAY ); Serial . print ( element ); Serial . print ( \"|\" ); } vTaskDelete ( NULL ); } void setup_QueuesBetweenTask () { queue = xQueueCreate ( queueSize , sizeof ( int )); if ( queue == NULL ) { Serial . println ( \"Error creating the queue\" ); } xTaskCreate ( producerTask , /* Task function. */ \"Producer\" , /* String with name of task. */ 10000 , /* Stack size in words. */ NULL , /* Parameter passed as input of the task */ 1 , /* Priority of the task. */ NULL ); /* Task handle. */ xTaskCreate ( consumerTask , /* Task function. */ \"Consumer\" , /* String with name of task. */ 10000 , /* Stack size in words. */ NULL , /* Parameter passed as input of the task */ 1 , /* Priority of the task. */ NULL ); /* Task handle. */ } void loop_QueuesBetweenTask () { delay ( 100000 ); }","title":"QueuesBetweenTask.cpp"},{"location":"GIT/","text":"Basics Of Git and GitHub Git is a distributed version control tool that a developer installs locally on their computer, that can manage a development project\u2019s source code history, while GitHub is a cloud based platform built around the Git tool. GitHub is an online service that stores code pushed to it from computers running the Git tool. Here, we will learn and master all the basics of Git and GitHub. Git Installation For Windows To download and install Git for Windows, go to this link. This will download the installer. Run the installer, and go along with the default installation settings. Once installation completes, the Git commands can be run from the Command Prompt or Windows Powershell. For Linux On the Linux terminal, run the following command- 1 > sudo apt-get install git Configuration Git for Windows provides an application called Git Bash, which provides an emulation layer for Git command line experience. In order to use it, simply launch the Git Bash application. To use Git commands for a specific directory, navigate to the destination by using the change directory command. Alternatively, open the destination folder, right click and select the \u2018Git Bash Here\u2019 option from the menu. After installation, it is ideal to run the following commands from Git Bash to provide configuration information- 1 2 $ git config --global user.name \"user-name\" $ git config --global user.email \"user-email\" Basic Git Commands Before we move on to Git commands, it is crucial to understand how the process of using Git actually works. Essentially, when you save the current state of your project in Git, it takes a snapshot of what your project looks like at that very instant. Since we can save many versions of the same project in Git, if we encounter an error during the course of development, it is possible to revert back to the last version of the project that worked, using Git. This eliminates the time and energy that we would otherwise have spent in starting all over. Git has 3 states your files can reside in: Committed means that the data is safely stored in the local database. Modified means that the files have been changed but not committed yet. Staged means that the files have been marked in their current version, and can be committed. The project resides in our local directory or repository. When we make changes to files in such a directory, the files are said to have been \u2018modified\u2019. When we stage a file, we add a snapshot of it to the staging area. Once we commit such a file, it\u2019s snapshot from the staging area is saved permanently in the Git directory. Use the git init command to create a new Git repository from a working directory on the system. On the Git Bash, navigate to the working directory, and run the following- 1 $ git init After this, add the files to the staging area. 1 $ git add . to add all the files in the working repository OR 1 $ git add filename to add a specific file. Now, these files are present in the staging area. In order to commit them to the Git directory, run the following command- 1 $ git commit -m \"MESSAGE\" The message string should preferably be something that neatly sums up the changes that have been made, making the version more recognizable. Git and GitHub basic commands As discussed earlier, GitHub is an online cloud service built around Git Tools. It makes it extremely convenient for developers to collaborate and share repositories, codes, etc. It has powerful features like pull, merge and fork, which facilitate collaboration. To use Github, first set up a GitHub account. Next, create a new repository. Add in the details, like the name, description etc., and create the repository. Once this is done, we need to establish a remote connection between the GitHub repository that we have just created, and the Git Repository on our system. To do this, run the following command- 1 $ git remote add remote-name github-repository-url Replace the remote-name with a name of your choice, and the github-repository-url with the url of the repository you want to add a remote connection to. Next, we push the files in our git directory to this GitHub repository. 1 $ git push remote-name branch-name A branch name can be specified if the files have to be pushed to a branch other than the master branch. Branching of GitHub Repositories Branches are used to isolate work without affecting other branches. It can be used to develop new features, fix bugs, and experiment with new ideas. In order to create a branch, simply navigate to the main page of the repository and click the branch selector menu. There, enter the name of the branch you wish to create. When we have a project with multiple branches, sometimes we need to work in the branches other than master. To do this, run the following command from Git Bash- 1 $ git checkout branch-name Cloning a GitHub Repository To clone a GitHub Repository in your system, run the following command and replace the repository-url with the url of the repository you wish to clone- 1 $ git clone repository-url Forks and Pull Requests To fork someone else\u2019s GitHub Repository to your account, first go to the repository you wish to fork, and click the \u2018Fork\u2019 option. Forking will create your own version of the desired repository. Any changes that you make and commit will reflect in your forked version of the repository, and not the original. However, there is a mechanism in place, which allows you to request the original owner of the repository to include the changes you have made and incorporate them in their repositories, if they so see fit. This is called sending a pull request. Choose the compare across forks option. On the left, select the repository and it\u2019s branch that you wish to merge with, and on the right, select the repository and the branch you want to merge to the original repository. Pull requests can also be made across branches of the same repository. Once you select the repositories, GitHub will verify if they can be merged. If so, it will open up a menu for you to fill details about the pull request in. You can specify a title, detailed description etc. Once these details are filled, click on \u2018Create a Pull Request\u2019. A request will be sent to the owner of the first repository to review the changes. If approved, your repository will be merged with the original. For further reference, visit: https://git-scm.com/book/en/v1/Getting-Started-Git-Basics https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f","title":"GIT"},{"location":"GIT/#basics-of-git-and-github","text":"Git is a distributed version control tool that a developer installs locally on their computer, that can manage a development project\u2019s source code history, while GitHub is a cloud based platform built around the Git tool. GitHub is an online service that stores code pushed to it from computers running the Git tool. Here, we will learn and master all the basics of Git and GitHub.","title":"Basics Of Git and GitHub"},{"location":"GIT/#git-installation","text":"","title":"Git Installation"},{"location":"GIT/#for-windows","text":"To download and install Git for Windows, go to this link. This will download the installer. Run the installer, and go along with the default installation settings. Once installation completes, the Git commands can be run from the Command Prompt or Windows Powershell.","title":"For Windows"},{"location":"GIT/#for-linux","text":"On the Linux terminal, run the following command- 1 > sudo apt-get install git","title":"For Linux"},{"location":"GIT/#configuration","text":"Git for Windows provides an application called Git Bash, which provides an emulation layer for Git command line experience. In order to use it, simply launch the Git Bash application. To use Git commands for a specific directory, navigate to the destination by using the change directory command. Alternatively, open the destination folder, right click and select the \u2018Git Bash Here\u2019 option from the menu. After installation, it is ideal to run the following commands from Git Bash to provide configuration information- 1 2 $ git config --global user.name \"user-name\" $ git config --global user.email \"user-email\"","title":"Configuration"},{"location":"GIT/#basic-git-commands","text":"Before we move on to Git commands, it is crucial to understand how the process of using Git actually works. Essentially, when you save the current state of your project in Git, it takes a snapshot of what your project looks like at that very instant. Since we can save many versions of the same project in Git, if we encounter an error during the course of development, it is possible to revert back to the last version of the project that worked, using Git. This eliminates the time and energy that we would otherwise have spent in starting all over. Git has 3 states your files can reside in: Committed means that the data is safely stored in the local database. Modified means that the files have been changed but not committed yet. Staged means that the files have been marked in their current version, and can be committed. The project resides in our local directory or repository. When we make changes to files in such a directory, the files are said to have been \u2018modified\u2019. When we stage a file, we add a snapshot of it to the staging area. Once we commit such a file, it\u2019s snapshot from the staging area is saved permanently in the Git directory. Use the git init command to create a new Git repository from a working directory on the system. On the Git Bash, navigate to the working directory, and run the following- 1 $ git init After this, add the files to the staging area. 1 $ git add . to add all the files in the working repository OR 1 $ git add filename to add a specific file. Now, these files are present in the staging area. In order to commit them to the Git directory, run the following command- 1 $ git commit -m \"MESSAGE\" The message string should preferably be something that neatly sums up the changes that have been made, making the version more recognizable.","title":"Basic Git Commands"},{"location":"GIT/#git-and-github-basic-commands","text":"As discussed earlier, GitHub is an online cloud service built around Git Tools. It makes it extremely convenient for developers to collaborate and share repositories, codes, etc. It has powerful features like pull, merge and fork, which facilitate collaboration. To use Github, first set up a GitHub account. Next, create a new repository. Add in the details, like the name, description etc., and create the repository. Once this is done, we need to establish a remote connection between the GitHub repository that we have just created, and the Git Repository on our system. To do this, run the following command- 1 $ git remote add remote-name github-repository-url Replace the remote-name with a name of your choice, and the github-repository-url with the url of the repository you want to add a remote connection to. Next, we push the files in our git directory to this GitHub repository. 1 $ git push remote-name branch-name A branch name can be specified if the files have to be pushed to a branch other than the master branch. Branching of GitHub Repositories Branches are used to isolate work without affecting other branches. It can be used to develop new features, fix bugs, and experiment with new ideas. In order to create a branch, simply navigate to the main page of the repository and click the branch selector menu. There, enter the name of the branch you wish to create. When we have a project with multiple branches, sometimes we need to work in the branches other than master. To do this, run the following command from Git Bash- 1 $ git checkout branch-name","title":"Git and GitHub basic commands"},{"location":"GIT/#cloning-a-github-repository","text":"To clone a GitHub Repository in your system, run the following command and replace the repository-url with the url of the repository you wish to clone- 1 $ git clone repository-url","title":"Cloning a GitHub Repository"},{"location":"GIT/#forks-and-pull-requests","text":"To fork someone else\u2019s GitHub Repository to your account, first go to the repository you wish to fork, and click the \u2018Fork\u2019 option. Forking will create your own version of the desired repository. Any changes that you make and commit will reflect in your forked version of the repository, and not the original. However, there is a mechanism in place, which allows you to request the original owner of the repository to include the changes you have made and incorporate them in their repositories, if they so see fit. This is called sending a pull request. Choose the compare across forks option. On the left, select the repository and it\u2019s branch that you wish to merge with, and on the right, select the repository and the branch you want to merge to the original repository. Pull requests can also be made across branches of the same repository. Once you select the repositories, GitHub will verify if they can be merged. If so, it will open up a menu for you to fill details about the pull request in. You can specify a title, detailed description etc. Once these details are filled, click on \u2018Create a Pull Request\u2019. A request will be sent to the owner of the first repository to review the changes. If approved, your repository will be merged with the original. For further reference, visit: https://git-scm.com/book/en/v1/Getting-Started-Git-Basics https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f","title":"Forks and Pull Requests"},{"location":"Hardware/","text":"Hardware design Schematic of IOT-A-Sync","title":"Schematic"},{"location":"Hardware/#hardware-design","text":"","title":"Hardware design"},{"location":"Hardware/#schematic-of-iot-a-sync","text":"","title":"Schematic of IOT-A-Sync"},{"location":"LORA/","text":"LORA LoRa is a wireless technology that offers long range, low power and secure data transmission for M2M and IoT applications. LoRa is based on chirp spread spectrum modulation, which has low power characteristics like FSK modulation but can be used for long range communications. LoRa can be used to connect sensors, gateways, machines, devices, animals, people etc. wirelessly to the cloud. LoRa Technologies operates in different frequency bands in different regions: In the United States it operates in the 915 MHz band, in Europe it operates in the 868 MHz band and in Asia it operates in the 865 to 867 MHz, 920 to 923 MHz band. Library used https://github.com/sandeepmistry/arduino-LoRa Example Lora sender 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <SPI.h> #include <LoRa.h> #define SCK 18 // GPIO5 -- SX127x's SCK #define MISO 19 // GPIO19 -- SX127x's MISO #define MOSI 23 // GPIO27 -- SX127x's MOSI #define SS 5 // GPIO18 -- SX127x's CS #define RST 27 // GPIO14 -- SX127x's RESET #define DI0 16 // GPIO26 -- SX127x's IRQ(Interrupt Request) #define BAND 868E6 //you can set band here directly,e.g. 868E6,915E6 #define PABOOST true int counter = 0 ; void setup () { Serial . begin ( 115200 ); while ( ! Serial ); Serial . println ( \"LoRa Sender\" ); SPI . begin ( SCK , MISO , MOSI , SS ); LoRa . setPins ( SS , RST , DI0 ); if ( ! LoRa . begin ( BAND )) { Serial . println ( \"Starting LoRa failed!\" ); while ( 1 ); } } void loop () { Serial . print ( \"Sending packet: \" ); Serial . println ( counter ); // send packet LoRa . beginPacket (); LoRa . print ( \"hello \" ); LoRa . print ( counter ); LoRa . endPacket (); counter ++ ; delay ( 5000 ); } Lora Reciever callback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <SPI.h> #include <LoRa.h> #ifdef ARDUINO_SAMD_MKRWAN1300 #error \"This example is not compatible with the Arduino MKR WAN 1300 board!\" #endif #define SCK 18 // GPIO5 -- SX127x's SCK #define MISO 19 // GPIO19 -- SX127x's MISO #define MOSI 23 // GPIO27 -- SX127x's MOSI #define SS 5 // GPIO18 -- SX127x's CS #define RST 27 // GPIO14 -- SX127x's RESET #define DI0 16 // GPIO26 -- SX127x's IRQ(Interrupt Request) #define BAND 868E6 //you can set band here directly,e.g. 868E6,915E6 #define PABOOST true void setup () { Serial . begin ( 115200 ); while ( ! Serial ); Serial . println ( \"LoRa Receiver Callback\" ); SPI . begin ( SCK , MISO , MOSI , SS ); LoRa . setPins ( SS , RST , DI0 ); if ( ! LoRa . begin ( BAND )) { Serial . println ( \"Starting LoRa failed!\" ); while ( 1 ); } // register the receive callback LoRa . onReceive ( onReceive ); // put the radio into receive mode LoRa . receive (); } void loop () { // do nothing } void onReceive ( int packetSize ) { // received a packet Serial . print ( \"Received packet '\" ); // read packet for ( int i = 0 ; i < packetSize ; i ++ ) { Serial . print (( char ) LoRa . read ()); } // print RSSI of packet Serial . print ( \"' with RSSI \" ); Serial . println ( LoRa . packetRssi ()); } Output","title":"LORA"},{"location":"LORA/#lora","text":"LoRa is a wireless technology that offers long range, low power and secure data transmission for M2M and IoT applications. LoRa is based on chirp spread spectrum modulation, which has low power characteristics like FSK modulation but can be used for long range communications. LoRa can be used to connect sensors, gateways, machines, devices, animals, people etc. wirelessly to the cloud. LoRa Technologies operates in different frequency bands in different regions: In the United States it operates in the 915 MHz band, in Europe it operates in the 868 MHz band and in Asia it operates in the 865 to 867 MHz, 920 to 923 MHz band.","title":"LORA"},{"location":"LORA/#library-used","text":"https://github.com/sandeepmistry/arduino-LoRa","title":"Library used"},{"location":"LORA/#example","text":"","title":"Example"},{"location":"LORA/#lora-sender","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <SPI.h> #include <LoRa.h> #define SCK 18 // GPIO5 -- SX127x's SCK #define MISO 19 // GPIO19 -- SX127x's MISO #define MOSI 23 // GPIO27 -- SX127x's MOSI #define SS 5 // GPIO18 -- SX127x's CS #define RST 27 // GPIO14 -- SX127x's RESET #define DI0 16 // GPIO26 -- SX127x's IRQ(Interrupt Request) #define BAND 868E6 //you can set band here directly,e.g. 868E6,915E6 #define PABOOST true int counter = 0 ; void setup () { Serial . begin ( 115200 ); while ( ! Serial ); Serial . println ( \"LoRa Sender\" ); SPI . begin ( SCK , MISO , MOSI , SS ); LoRa . setPins ( SS , RST , DI0 ); if ( ! LoRa . begin ( BAND )) { Serial . println ( \"Starting LoRa failed!\" ); while ( 1 ); } } void loop () { Serial . print ( \"Sending packet: \" ); Serial . println ( counter ); // send packet LoRa . beginPacket (); LoRa . print ( \"hello \" ); LoRa . print ( counter ); LoRa . endPacket (); counter ++ ; delay ( 5000 ); }","title":"Lora sender"},{"location":"LORA/#lora-reciever-callback","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <SPI.h> #include <LoRa.h> #ifdef ARDUINO_SAMD_MKRWAN1300 #error \"This example is not compatible with the Arduino MKR WAN 1300 board!\" #endif #define SCK 18 // GPIO5 -- SX127x's SCK #define MISO 19 // GPIO19 -- SX127x's MISO #define MOSI 23 // GPIO27 -- SX127x's MOSI #define SS 5 // GPIO18 -- SX127x's CS #define RST 27 // GPIO14 -- SX127x's RESET #define DI0 16 // GPIO26 -- SX127x's IRQ(Interrupt Request) #define BAND 868E6 //you can set band here directly,e.g. 868E6,915E6 #define PABOOST true void setup () { Serial . begin ( 115200 ); while ( ! Serial ); Serial . println ( \"LoRa Receiver Callback\" ); SPI . begin ( SCK , MISO , MOSI , SS ); LoRa . setPins ( SS , RST , DI0 ); if ( ! LoRa . begin ( BAND )) { Serial . println ( \"Starting LoRa failed!\" ); while ( 1 ); } // register the receive callback LoRa . onReceive ( onReceive ); // put the radio into receive mode LoRa . receive (); } void loop () { // do nothing } void onReceive ( int packetSize ) { // received a packet Serial . print ( \"Received packet '\" ); // read packet for ( int i = 0 ; i < packetSize ; i ++ ) { Serial . print (( char ) LoRa . read ()); } // print RSSI of packet Serial . print ( \"' with RSSI \" ); Serial . println ( LoRa . packetRssi ()); }","title":"Lora Reciever callback"},{"location":"LORA/#output","text":"","title":"Output"},{"location":"LORA/LORAWAN/","text":"LORAWAN LoRaWAN is a Low Power, Wide Area (LPWA) networking protocol developed by the LoRa Alliance, that wirelessly connects battery operated \u2018things\u2019 to the internet in regional, national or global networks, targeting key Internet of Things (IoT) requirements such as bi-directional communication, end-to-end security, mobility and localization services. LoRaWAN uses unlicensed spectrum in the ISM bands to define the communication protocol and system architecture for the network while the LoRa physical layer creates the long-range communication links between remote sensors and gateways connected to the network. This protocol helps in the quick setup of public or private IoT networks anywhere using hardware and software. LoRa is the physical layer i.e. the chip and LoRaWAN is the MAC layer i.e. the software that\u2019s put on the chip to enable networking. Example :- ChirpStack and TTN","title":"LORAWAN"},{"location":"LORA/LORAWAN/#lorawan","text":"LoRaWAN is a Low Power, Wide Area (LPWA) networking protocol developed by the LoRa Alliance, that wirelessly connects battery operated \u2018things\u2019 to the internet in regional, national or global networks, targeting key Internet of Things (IoT) requirements such as bi-directional communication, end-to-end security, mobility and localization services. LoRaWAN uses unlicensed spectrum in the ISM bands to define the communication protocol and system architecture for the network while the LoRa physical layer creates the long-range communication links between remote sensors and gateways connected to the network. This protocol helps in the quick setup of public or private IoT networks anywhere using hardware and software. LoRa is the physical layer i.e. the chip and LoRaWAN is the MAC layer i.e. the software that\u2019s put on the chip to enable networking. Example :- ChirpStack and TTN","title":"LORAWAN"},{"location":"MQTT/","text":"MQTT What is MQTT? MQTT, or MQ Telemetry Transport, has become a de facto standard in this world, as it\u2019s easy to set up, and works well without a lot of computing overhead. \u201cMQ\u201d at one time stood for Message Queuing, but it has now apparently transcended its acronym status. How Does MQTT Work? MQTT uses a publish-subscribe methodology, where clients send and receive messages to each other through a centralized broker, also sometimes called a server. Clients both publish and subscribe to information channels called topics, and any data that passes on via the broker is tagged with a topic label. Once clients are pointed to the broker\u2019s IP address, there\u2019s no more system configuration involved. Clients simply send messages to a topic (that may or may not exist elsewhere) by publishing topic-tagged data to it. Clients listen to topics by subscribing to them. Note that each client knows nothing about the other clients on the network; the broker merely takes care of data distribution. This can be to one client, many clients, or none, if nothing else is actually subscribed. All a client needs to know is where to find the broker/server. If a client\u2019s IP address changes, or there are other modifications in the underlying system, as long as each client knows where to find the server, things will still function properly. There are many ready to go and opensource mqtt client is available eg. mqtt fx , mqtt lens etc. We can use then for teeting and visualisation purposes. Example Output platformio.ini 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ;PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32dev] platform = espressif32 framework = arduino board = esp32dev board_build.f_cpu = 160000000L board_build.f_flash = 80000000L board_build.flash_mode = qio build_flags = -DWEBSOCKET_DISABLED = true lib_deps = ArduinoJson@~5.13.4 ; LoRa, ; https://github.com/adafruit/Adafruit-GFX-Library.git ; https://github.com/MrityunjaiKumar/esp8266-oled-ssd1306.git ; https://github.com/MrityunjaiKumar/HELTEC_OLED.git ; https://github.com/ThingPulse/esp8266-oled-ssd1306.git ; https://github.com/adafruit/RadioHead.git ; https://github.com/JoaoLopesF/RemoteDebug.git ; https://github.com/MrityunjaiKumar/Heltec_ESP32_Lora.git https://github.com/knolleary/pubsubclient.git https://github.com/adafruit/Adafruit_Sensor.git https://github.com/adafruit/Adafruit_BME280_Library.git monitor_speed = 115200 monitor_port = ${common.port} upload_speed = 921600 upload_port = ${common.port} ; upload_port=192.168.0.247 [common] port = COM11 main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include <Arduino.h> #include \"common.h\" #include <WiFi.h> #include \"mqtt_credential.h\" #include <Wire.h> #include <WiFi.h> #include <PubSubClient.h> #define use_dummy_data FALSE // Replace the next variables with your SSID/Password combination const char * ssid = WIFI_SSID ; const char * password = WIFI_PASSWORD ; // Add your MQTT Broker IP address, example: //const char* mqtt_server = \"192.168.1.144\"; const char * mqtt_server = broker_address ; WiFiClient espClient ; PubSubClient client ( espClient ); long lastMsg = 0 ; char msg [ 50 ]; int value = 0 ; void setup_wifi () { delay ( 10 ); // We start by connecting to a WiFi network Serial . println (); Serial . print ( \"Connecting to \" ); Serial . println ( ssid ); WiFi . begin ( ssid , password ); while ( WiFi . status () != WL_CONNECTED ) { delay ( 500 ); Serial . print ( \".\" ); } Serial . println ( \"\" ); Serial . println ( \"WiFi connected\" ); Serial . println ( \"IP address: \" ); Serial . println ( WiFi . localIP ()); } void setup () { Serial . begin ( 115200 ); setup_wifi (); client . setServer ( mqtt_server , broker_port ); client . setCallback ( callback ); // #if !(use_dummy_data) // bme_setup(); // #endif randomSeed ( analogRead ( 0 )); } void callback ( char * topic , byte * message , unsigned int length ) { Serial . print ( \"Message arrived on topic: \" ); Serial . print ( topic ); Serial . print ( \". Message: \" ); String messageTemp ; for ( int i = 0 ; i < length ; i ++ ) { Serial . print (( char ) message [ i ]); messageTemp += ( char ) message [ i ]; } Serial . println (); } void reconnect () { // Loop until we're reconnected while ( ! client . connected ()) { Serial . print ( \"Attempting MQTT connection...\" ); // Attempt to connect if ( client . connect ( \"demo\" , mqtt_client_username , mqtt_client_password )) { Serial . println ( \"connected\" ); // Subscribe client . subscribe ( \"Tank_node_sub\" ); } else { Serial . print ( \"failed, rc=\" ); Serial . print ( client . state ()); Serial . println ( \" try again in 5 seconds\" ); // Wait 5 seconds before retrying delay ( 5000 ); } } } void loop () { if ( ! client . connected ()) { reconnect (); } client . loop (); long now = millis (); if ( now - lastMsg > 5000 ) { lastMsg = now ; // #if !(use_dummy_data) // client.publish(mqtt_publish_topic, get_BME_payload().c_str()); // #else client . publish ( mqtt_publish_topic , get_dummy_BME_payload (). c_str ()); // #endif // Serial.println(get_BME_payload()); } } common.h 1 2 3 4 5 6 7 8 9 10 #ifndef _COMMOM_H #define _COMMOM_H #include <Arduino.h> void callback(char *topic, byte *message, unsigned int length); void reconnect(); void setup_wifi(); void bme_setup(); String get_BME_payload(); String get_dummy_BME_payload(); #endif //_COMMOM_H mqtt_credential.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #ifndef _MQTT_CREDENTIALS_H #define _MQTT_CREDENTIALS_H #define WIFI_SSID \"sincgrid\" #define WIFI_PASSWORD \"sincgrid.com\" #define broker_address \"192.168.0.106\" #define broker_port 1883 #define mqtt_client_username \"\" #define mqtt_client_password \"\" #define mqtt_subscribe_topic \"IOTASYNC/sub\" #define mqtt_publish_topic \"IOTASYNC/demo\" #endif //_MQTT_CREDENTIALS_H` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 #include \"common.h\" #include <ArduinoJson.h> #include <Adafruit_Sensor.h> #include <Adafruit_BME280.h> Adafruit_BME280 bme ; float temperature , humidity , pressure , altitude ; #define SEALEVELPRESSURE_HPA (1050) void bme_setup () { // put your setup code here, to run once: delay ( 100 ); bme . begin ( 0x76 ); } void bme_loop () { // put your main code here, to run repeatedly: temperature = bme . readTemperature (); humidity = bme . readHumidity (); pressure = bme . readPressure () / 100.0F ; altitude = bme . readAltitude ( SEALEVELPRESSURE_HPA ); Serial . print ( \"Temperature = \" ); Serial . print ( temperature ); Serial . println ( \" *C\" ); // Convert temperature to Fahrenheit /*Serial.print(\"Temperature = \"); Serial.print(1.8 * bme.readTemperature() + 32); Serial.println(\" *F\");*/ Serial . print ( \"Pressure = \" ); Serial . print ( pressure ); Serial . println ( \" hPa\" ); Serial . print ( \"Approx. Altitude = \" ); Serial . print ( altitude ); Serial . println ( \" m\" ); Serial . print ( \"Humidity = \" ); Serial . print ( humidity ); Serial . println ( \" %\" ); Serial . println (); delay ( 1000 ); } String get_BME_payload () { String message = \"\" ; temperature = bme . readTemperature (); humidity = bme . readHumidity (); pressure = bme . readPressure () / 100.0F ; altitude = bme . readAltitude ( SEALEVELPRESSURE_HPA ); // Serial.print(\"Temperature = \"); // Serial.print(temperature); // Serial.println(\" *C\"); // // Convert temperature to Fahrenheit // /*Serial.print(\"Temperature = \"); // Serial.print(1.8 * bme.readTemperature() + 32); // Serial.println(\" *F\");*/ // Serial.print(\"Pressure = \"); // Serial.print(pressure); // Serial.println(\" hPa\"); // Serial.print(\"Approx. Altitude = \"); // Serial.print(altitude); // Serial.println(\" m\"); // Serial.print(\"Humidity = \"); // Serial.print(humidity); // Serial.println(\" %\"); // Serial.println(); //Encoder function StaticJsonBuffer < 200 > jsonBuffer ; JsonObject & root = jsonBuffer . createObject (); root [ \"dev_id\" ] = \"demo\" ; JsonObject & iotasync_data = root . createNestedObject ( \"iotasync_data\" ); iotasync_data [ \"temp\" ] = String ( temperature ); iotasync_data [ \"alt\" ] = String ( altitude ); iotasync_data [ \"humidity\" ] = String ( humidity ); iotasync_data [ \"pressure\" ] = String ( pressure ); char JSONmessageBuffer [ 200 ]; root . printTo ( JSONmessageBuffer , sizeof ( JSONmessageBuffer )); message += String ( JSONmessageBuffer ); // StaticJsonBuffer<200> jsonBuffer2; // JsonObject &root_out = jsonBuffer2.createObject(); // char JSONmessageBuffer2[200]; // root_out.printTo(JSONmessageBuffer2, sizeof(JSONmessageBuffer2)); // message_outer += String(JSONmessageBuffer2); Serial . println ( message ); return message ; } String get_dummy_BME_payload (){ String message = \"\" ; temperature = random ( 16 , 17 ); humidity = random ( 45 , 47 ); pressure = random ( 5300 , 5500 ) / 100.0F ; altitude = random ( 12 , 13 ); //Encoder function StaticJsonBuffer < 200 > jsonBuffer ; JsonObject & root = jsonBuffer . createObject (); root [ \"dev_id\" ] = \"demo\" ; JsonObject & iotasync_data = root . createNestedObject ( \"iotasync_data\" ); iotasync_data [ \"temp\" ] = String ( temperature ); iotasync_data [ \"alt\" ] = String ( altitude ); iotasync_data [ \"humidity\" ] = String ( humidity ); iotasync_data [ \"pressure\" ] = String ( pressure ); char JSONmessageBuffer [ 200 ]; root . printTo ( JSONmessageBuffer , sizeof ( JSONmessageBuffer )); message += String ( JSONmessageBuffer ); // StaticJsonBuffer<200> jsonBuffer2; // JsonObject &root_out = jsonBuffer2.createObject(); // char JSONmessageBuffer2[200]; // root_out.printTo(JSONmessageBuffer2, sizeof(JSONmessageBuffer2)); // message_outer += String(JSONmessageBuffer2); Serial . println ( message ); return message ; } Git repository link for codes :- Repo","title":"MQTT"},{"location":"MQTT/#mqtt","text":"","title":"MQTT"},{"location":"MQTT/#what-is-mqtt","text":"MQTT, or MQ Telemetry Transport, has become a de facto standard in this world, as it\u2019s easy to set up, and works well without a lot of computing overhead. \u201cMQ\u201d at one time stood for Message Queuing, but it has now apparently transcended its acronym status.","title":"What is MQTT?"},{"location":"MQTT/#how-does-mqtt-work","text":"MQTT uses a publish-subscribe methodology, where clients send and receive messages to each other through a centralized broker, also sometimes called a server. Clients both publish and subscribe to information channels called topics, and any data that passes on via the broker is tagged with a topic label. Once clients are pointed to the broker\u2019s IP address, there\u2019s no more system configuration involved. Clients simply send messages to a topic (that may or may not exist elsewhere) by publishing topic-tagged data to it. Clients listen to topics by subscribing to them. Note that each client knows nothing about the other clients on the network; the broker merely takes care of data distribution. This can be to one client, many clients, or none, if nothing else is actually subscribed. All a client needs to know is where to find the broker/server. If a client\u2019s IP address changes, or there are other modifications in the underlying system, as long as each client knows where to find the server, things will still function properly. There are many ready to go and opensource mqtt client is available eg. mqtt fx , mqtt lens etc. We can use then for teeting and visualisation purposes.","title":"How Does MQTT Work?"},{"location":"MQTT/#example","text":"","title":"Example"},{"location":"MQTT/#output","text":"","title":"Output"},{"location":"MQTT/#platformioini","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ;PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32dev] platform = espressif32 framework = arduino board = esp32dev board_build.f_cpu = 160000000L board_build.f_flash = 80000000L board_build.flash_mode = qio build_flags = -DWEBSOCKET_DISABLED = true lib_deps = ArduinoJson@~5.13.4 ; LoRa, ; https://github.com/adafruit/Adafruit-GFX-Library.git ; https://github.com/MrityunjaiKumar/esp8266-oled-ssd1306.git ; https://github.com/MrityunjaiKumar/HELTEC_OLED.git ; https://github.com/ThingPulse/esp8266-oled-ssd1306.git ; https://github.com/adafruit/RadioHead.git ; https://github.com/JoaoLopesF/RemoteDebug.git ; https://github.com/MrityunjaiKumar/Heltec_ESP32_Lora.git https://github.com/knolleary/pubsubclient.git https://github.com/adafruit/Adafruit_Sensor.git https://github.com/adafruit/Adafruit_BME280_Library.git monitor_speed = 115200 monitor_port = ${common.port} upload_speed = 921600 upload_port = ${common.port} ; upload_port=192.168.0.247 [common] port = COM11","title":"platformio.ini"},{"location":"MQTT/#maincpp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include <Arduino.h> #include \"common.h\" #include <WiFi.h> #include \"mqtt_credential.h\" #include <Wire.h> #include <WiFi.h> #include <PubSubClient.h> #define use_dummy_data FALSE // Replace the next variables with your SSID/Password combination const char * ssid = WIFI_SSID ; const char * password = WIFI_PASSWORD ; // Add your MQTT Broker IP address, example: //const char* mqtt_server = \"192.168.1.144\"; const char * mqtt_server = broker_address ; WiFiClient espClient ; PubSubClient client ( espClient ); long lastMsg = 0 ; char msg [ 50 ]; int value = 0 ; void setup_wifi () { delay ( 10 ); // We start by connecting to a WiFi network Serial . println (); Serial . print ( \"Connecting to \" ); Serial . println ( ssid ); WiFi . begin ( ssid , password ); while ( WiFi . status () != WL_CONNECTED ) { delay ( 500 ); Serial . print ( \".\" ); } Serial . println ( \"\" ); Serial . println ( \"WiFi connected\" ); Serial . println ( \"IP address: \" ); Serial . println ( WiFi . localIP ()); } void setup () { Serial . begin ( 115200 ); setup_wifi (); client . setServer ( mqtt_server , broker_port ); client . setCallback ( callback ); // #if !(use_dummy_data) // bme_setup(); // #endif randomSeed ( analogRead ( 0 )); } void callback ( char * topic , byte * message , unsigned int length ) { Serial . print ( \"Message arrived on topic: \" ); Serial . print ( topic ); Serial . print ( \". Message: \" ); String messageTemp ; for ( int i = 0 ; i < length ; i ++ ) { Serial . print (( char ) message [ i ]); messageTemp += ( char ) message [ i ]; } Serial . println (); } void reconnect () { // Loop until we're reconnected while ( ! client . connected ()) { Serial . print ( \"Attempting MQTT connection...\" ); // Attempt to connect if ( client . connect ( \"demo\" , mqtt_client_username , mqtt_client_password )) { Serial . println ( \"connected\" ); // Subscribe client . subscribe ( \"Tank_node_sub\" ); } else { Serial . print ( \"failed, rc=\" ); Serial . print ( client . state ()); Serial . println ( \" try again in 5 seconds\" ); // Wait 5 seconds before retrying delay ( 5000 ); } } } void loop () { if ( ! client . connected ()) { reconnect (); } client . loop (); long now = millis (); if ( now - lastMsg > 5000 ) { lastMsg = now ; // #if !(use_dummy_data) // client.publish(mqtt_publish_topic, get_BME_payload().c_str()); // #else client . publish ( mqtt_publish_topic , get_dummy_BME_payload (). c_str ()); // #endif // Serial.println(get_BME_payload()); } }","title":"main.cpp"},{"location":"MQTT/#commonh","text":"1 2 3 4 5 6 7 8 9 10 #ifndef _COMMOM_H #define _COMMOM_H #include <Arduino.h> void callback(char *topic, byte *message, unsigned int length); void reconnect(); void setup_wifi(); void bme_setup(); String get_BME_payload(); String get_dummy_BME_payload(); #endif //_COMMOM_H","title":"common.h"},{"location":"MQTT/#mqtt_credentialh","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 #ifndef _MQTT_CREDENTIALS_H #define _MQTT_CREDENTIALS_H #define WIFI_SSID \"sincgrid\" #define WIFI_PASSWORD \"sincgrid.com\" #define broker_address \"192.168.0.106\" #define broker_port 1883 #define mqtt_client_username \"\" #define mqtt_client_password \"\" #define mqtt_subscribe_topic \"IOTASYNC/sub\" #define mqtt_publish_topic \"IOTASYNC/demo\" #endif //_MQTT_CREDENTIALS_H` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 #include \"common.h\" #include <ArduinoJson.h> #include <Adafruit_Sensor.h> #include <Adafruit_BME280.h> Adafruit_BME280 bme ; float temperature , humidity , pressure , altitude ; #define SEALEVELPRESSURE_HPA (1050) void bme_setup () { // put your setup code here, to run once: delay ( 100 ); bme . begin ( 0x76 ); } void bme_loop () { // put your main code here, to run repeatedly: temperature = bme . readTemperature (); humidity = bme . readHumidity (); pressure = bme . readPressure () / 100.0F ; altitude = bme . readAltitude ( SEALEVELPRESSURE_HPA ); Serial . print ( \"Temperature = \" ); Serial . print ( temperature ); Serial . println ( \" *C\" ); // Convert temperature to Fahrenheit /*Serial.print(\"Temperature = \"); Serial.print(1.8 * bme.readTemperature() + 32); Serial.println(\" *F\");*/ Serial . print ( \"Pressure = \" ); Serial . print ( pressure ); Serial . println ( \" hPa\" ); Serial . print ( \"Approx. Altitude = \" ); Serial . print ( altitude ); Serial . println ( \" m\" ); Serial . print ( \"Humidity = \" ); Serial . print ( humidity ); Serial . println ( \" %\" ); Serial . println (); delay ( 1000 ); } String get_BME_payload () { String message = \"\" ; temperature = bme . readTemperature (); humidity = bme . readHumidity (); pressure = bme . readPressure () / 100.0F ; altitude = bme . readAltitude ( SEALEVELPRESSURE_HPA ); // Serial.print(\"Temperature = \"); // Serial.print(temperature); // Serial.println(\" *C\"); // // Convert temperature to Fahrenheit // /*Serial.print(\"Temperature = \"); // Serial.print(1.8 * bme.readTemperature() + 32); // Serial.println(\" *F\");*/ // Serial.print(\"Pressure = \"); // Serial.print(pressure); // Serial.println(\" hPa\"); // Serial.print(\"Approx. Altitude = \"); // Serial.print(altitude); // Serial.println(\" m\"); // Serial.print(\"Humidity = \"); // Serial.print(humidity); // Serial.println(\" %\"); // Serial.println(); //Encoder function StaticJsonBuffer < 200 > jsonBuffer ; JsonObject & root = jsonBuffer . createObject (); root [ \"dev_id\" ] = \"demo\" ; JsonObject & iotasync_data = root . createNestedObject ( \"iotasync_data\" ); iotasync_data [ \"temp\" ] = String ( temperature ); iotasync_data [ \"alt\" ] = String ( altitude ); iotasync_data [ \"humidity\" ] = String ( humidity ); iotasync_data [ \"pressure\" ] = String ( pressure ); char JSONmessageBuffer [ 200 ]; root . printTo ( JSONmessageBuffer , sizeof ( JSONmessageBuffer )); message += String ( JSONmessageBuffer ); // StaticJsonBuffer<200> jsonBuffer2; // JsonObject &root_out = jsonBuffer2.createObject(); // char JSONmessageBuffer2[200]; // root_out.printTo(JSONmessageBuffer2, sizeof(JSONmessageBuffer2)); // message_outer += String(JSONmessageBuffer2); Serial . println ( message ); return message ; } String get_dummy_BME_payload (){ String message = \"\" ; temperature = random ( 16 , 17 ); humidity = random ( 45 , 47 ); pressure = random ( 5300 , 5500 ) / 100.0F ; altitude = random ( 12 , 13 ); //Encoder function StaticJsonBuffer < 200 > jsonBuffer ; JsonObject & root = jsonBuffer . createObject (); root [ \"dev_id\" ] = \"demo\" ; JsonObject & iotasync_data = root . createNestedObject ( \"iotasync_data\" ); iotasync_data [ \"temp\" ] = String ( temperature ); iotasync_data [ \"alt\" ] = String ( altitude ); iotasync_data [ \"humidity\" ] = String ( humidity ); iotasync_data [ \"pressure\" ] = String ( pressure ); char JSONmessageBuffer [ 200 ]; root . printTo ( JSONmessageBuffer , sizeof ( JSONmessageBuffer )); message += String ( JSONmessageBuffer ); // StaticJsonBuffer<200> jsonBuffer2; // JsonObject &root_out = jsonBuffer2.createObject(); // char JSONmessageBuffer2[200]; // root_out.printTo(JSONmessageBuffer2, sizeof(JSONmessageBuffer2)); // message_outer += String(JSONmessageBuffer2); Serial . println ( message ); return message ; } Git repository link for codes :- Repo","title":"mqtt_credential.h"},{"location":"MQTT/websockets/","text":"Websockets WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection. MQTT over websockets MQTT over websockets allowes every browser to be a MQTT client. You can push messages to your browser when an event occurs or publish messages to your device. CloudMQTT Websockets Port (TLS only) can be found on the details page for your instance. WebSocket is distinct from HTTP. Both protocols are located at layer 7 in the OSI model and depend on TCP at layer 4. WebSocket is designed to work over HTTP ports 443 and 80 as well as to support HTTP proxies and intermediaries. To achieve compatibility, the WebSocket handshake uses the HTTP Upgrade header to change from the HTTP protocol to the WebSocket protocol. The WebSocket protocol enables interaction between a web browser (or other client application) and a web server with lower overhead than half-duplex alternatives such as HTTP polling, facilitating real-time data transfer from and to the server. This is made possible by providing a standardized way for the server to send content to the client without being first requested by the client, and allowing messages to be passed back and forth while keeping the connection open. In this way, a two-way ongoing conversation can take place between the client and the server. The communications are usually done over TCP port number 443 (or 80 in the case of unsecured connections), which is of benefit for those environments which block non-web Internet connections using a firewall. Javascript client example Demo.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // Called after form input is processed function startConnect () { // Generate a random client ID clientID = \"clientID-\" + parseInt ( Math . random () * 100 ); // Fetch the hostname/IP address and port number from the form host = document . getElementById ( \"host\" ). value ; port = document . getElementById ( \"port\" ). value ; // Print output for the user in the messages div document . getElementById ( \"messages\" ). innerHTML += '<span>Connecting to: ' + host + ' on port: ' + port + '</span><br/>' ; document . getElementById ( \"messages\" ). innerHTML += '<span>Using the following client value: ' + clientID + '</span><br/>' ; // Initialize new Paho client connection client = new Paho . MQTT . Client ( host , Number ( port ), clientID ); // Set callback handlers client . onConnectionLost = onConnectionLost ; client . onMessageArrived = onMessageArrived ; // Connect the client, if successful, call onConnect function client . connect ({ onSuccess : onConnect , }); } // Called when the client connects function onConnect () { // Fetch the MQTT topic from the form topic = document . getElementById ( \"topic\" ). value ; // Print output for the user in the messages div document . getElementById ( \"messages\" ). innerHTML += '<span>Subscribing to: ' + topic + '</span><br/>' ; // Subscribe to the requested topic client . subscribe ( topic ); } // Called when the client loses its connection function onConnectionLost ( responseObject ) { console . log ( \"onConnectionLost: Connection Lost\" ); if ( responseObject . errorCode !== 0 ) { console . log ( \"onConnectionLost: \" + responseObject . errorMessage ); } } // Called when a message arrives function onMessageArrived ( message ) { console . log ( \"onMessageArrived: \" + message . payloadString ); document . getElementById ( \"messages\" ). innerHTML += '<span>Topic: ' + message . destinationName + ' | ' + message . payloadString + '</span><br/>' ; updateScroll (); // Scroll to bottom of window } // Called when the disconnection button is pressed function startDisconnect () { client . disconnect (); document . getElementById ( \"messages\" ). innerHTML += '<span>Disconnected</span><br/>' ; updateScroll (); // Scroll to bottom of window } // Updates #messages div to auto-scroll function updateScroll () { var element = document . getElementById ( \"messages\" ); element . scrollTop = element . scrollHeight ; } Index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > mqtt-demo: A simple web application that can subscribe to topics from an MQTT broker over websockets </ title > < link rel = \"stylesheet\" href = \"style.css\" > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.2/mqttws31.min.js\" type = \"text/javascript\" ></ script > < script src = \"demo.js\" type = \"text/javascript\" ></ script > </ head > < body > < div class = \"wrapper\" > < h1 > mqtt-demo </ h1 > < form id = \"connection-information-form\" > < b > Hostname or IP Address: </ b > < input id = \"host\" type = \"text\" name = \"host\" value = \"test.mosquitto.org\" >< br > < b > Port: </ b > < input id = \"port\" type = \"text\" name = \"port\" value = \"8080\" >< br > < b > Topic: </ b > < input id = \"topic\" type = \"text\" name = \"topic\" value = \"#\" >< br >< br > < input type = \"button\" onclick = \"startConnect()\" value = \"Connect\" > < input type = \"button\" onclick = \"startDisconnect()\" value = \"Disconnect\" > </ form > < div id = \"messages\" ></ div > </ div > </ body > </ html >","title":"Websockets"},{"location":"MQTT/websockets/#websockets","text":"WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection.","title":"Websockets"},{"location":"MQTT/websockets/#mqtt-over-websockets","text":"MQTT over websockets allowes every browser to be a MQTT client. You can push messages to your browser when an event occurs or publish messages to your device. CloudMQTT Websockets Port (TLS only) can be found on the details page for your instance. WebSocket is distinct from HTTP. Both protocols are located at layer 7 in the OSI model and depend on TCP at layer 4. WebSocket is designed to work over HTTP ports 443 and 80 as well as to support HTTP proxies and intermediaries. To achieve compatibility, the WebSocket handshake uses the HTTP Upgrade header to change from the HTTP protocol to the WebSocket protocol. The WebSocket protocol enables interaction between a web browser (or other client application) and a web server with lower overhead than half-duplex alternatives such as HTTP polling, facilitating real-time data transfer from and to the server. This is made possible by providing a standardized way for the server to send content to the client without being first requested by the client, and allowing messages to be passed back and forth while keeping the connection open. In this way, a two-way ongoing conversation can take place between the client and the server. The communications are usually done over TCP port number 443 (or 80 in the case of unsecured connections), which is of benefit for those environments which block non-web Internet connections using a firewall.","title":"MQTT over websockets"},{"location":"MQTT/websockets/#javascript-client-example","text":"","title":"Javascript client example"},{"location":"MQTT/websockets/#demojs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // Called after form input is processed function startConnect () { // Generate a random client ID clientID = \"clientID-\" + parseInt ( Math . random () * 100 ); // Fetch the hostname/IP address and port number from the form host = document . getElementById ( \"host\" ). value ; port = document . getElementById ( \"port\" ). value ; // Print output for the user in the messages div document . getElementById ( \"messages\" ). innerHTML += '<span>Connecting to: ' + host + ' on port: ' + port + '</span><br/>' ; document . getElementById ( \"messages\" ). innerHTML += '<span>Using the following client value: ' + clientID + '</span><br/>' ; // Initialize new Paho client connection client = new Paho . MQTT . Client ( host , Number ( port ), clientID ); // Set callback handlers client . onConnectionLost = onConnectionLost ; client . onMessageArrived = onMessageArrived ; // Connect the client, if successful, call onConnect function client . connect ({ onSuccess : onConnect , }); } // Called when the client connects function onConnect () { // Fetch the MQTT topic from the form topic = document . getElementById ( \"topic\" ). value ; // Print output for the user in the messages div document . getElementById ( \"messages\" ). innerHTML += '<span>Subscribing to: ' + topic + '</span><br/>' ; // Subscribe to the requested topic client . subscribe ( topic ); } // Called when the client loses its connection function onConnectionLost ( responseObject ) { console . log ( \"onConnectionLost: Connection Lost\" ); if ( responseObject . errorCode !== 0 ) { console . log ( \"onConnectionLost: \" + responseObject . errorMessage ); } } // Called when a message arrives function onMessageArrived ( message ) { console . log ( \"onMessageArrived: \" + message . payloadString ); document . getElementById ( \"messages\" ). innerHTML += '<span>Topic: ' + message . destinationName + ' | ' + message . payloadString + '</span><br/>' ; updateScroll (); // Scroll to bottom of window } // Called when the disconnection button is pressed function startDisconnect () { client . disconnect (); document . getElementById ( \"messages\" ). innerHTML += '<span>Disconnected</span><br/>' ; updateScroll (); // Scroll to bottom of window } // Updates #messages div to auto-scroll function updateScroll () { var element = document . getElementById ( \"messages\" ); element . scrollTop = element . scrollHeight ; }","title":"Demo.js"},{"location":"MQTT/websockets/#indexhtml","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > mqtt-demo: A simple web application that can subscribe to topics from an MQTT broker over websockets </ title > < link rel = \"stylesheet\" href = \"style.css\" > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.2/mqttws31.min.js\" type = \"text/javascript\" ></ script > < script src = \"demo.js\" type = \"text/javascript\" ></ script > </ head > < body > < div class = \"wrapper\" > < h1 > mqtt-demo </ h1 > < form id = \"connection-information-form\" > < b > Hostname or IP Address: </ b > < input id = \"host\" type = \"text\" name = \"host\" value = \"test.mosquitto.org\" >< br > < b > Port: </ b > < input id = \"port\" type = \"text\" name = \"port\" value = \"8080\" >< br > < b > Topic: </ b > < input id = \"topic\" type = \"text\" name = \"topic\" value = \"#\" >< br >< br > < input type = \"button\" onclick = \"startConnect()\" value = \"Connect\" > < input type = \"button\" onclick = \"startDisconnect()\" value = \"Disconnect\" > </ form > < div id = \"messages\" ></ div > </ div > </ body > </ html >","title":"Index.html"},{"location":"Template/","text":"Paltform IO Tempalte platformio.ini 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ;PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32dev] platform = espressif32 framework = arduino board = esp32dev board_build.f_cpu = 160000000L board_build.f_flash = 80000000L board_build.flash_mode = qio build_flags = -DWEBSOCKET_DISABLED=true lib_deps = ArduinoJson@~5.13.4 https://github.com/mcci-catena/arduino-lmic.git monitor_speed = 115200 monitor_port = ${common.port} upload_speed = 921600 upload_port = ${common.port} ;;; uncomment above line, and comment next line to use uploading via com port ; upload_port=192.168.43.221 [common] port=COM29 main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <Arduino.h> #include \"Modules/modules.h\" void setup() { // put your setup code here, to run once: Serial.begin(115200); wifi_ota_setup(); lwic_setup(); } void loop() { // put your main code here, to run repeatedly: wifi_ota_loop(); lwic_loop(); } Git repository link for codes :- Repo","title":"Platform IO template"},{"location":"Template/#paltform-io-tempalte","text":"","title":"Paltform IO Tempalte"},{"location":"Template/#platformioini","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ;PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32dev] platform = espressif32 framework = arduino board = esp32dev board_build.f_cpu = 160000000L board_build.f_flash = 80000000L board_build.flash_mode = qio build_flags = -DWEBSOCKET_DISABLED=true lib_deps = ArduinoJson@~5.13.4 https://github.com/mcci-catena/arduino-lmic.git monitor_speed = 115200 monitor_port = ${common.port} upload_speed = 921600 upload_port = ${common.port} ;;; uncomment above line, and comment next line to use uploading via com port ; upload_port=192.168.43.221 [common] port=COM29","title":"platformio.ini"},{"location":"Template/#maincpp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <Arduino.h> #include \"Modules/modules.h\" void setup() { // put your setup code here, to run once: Serial.begin(115200); wifi_ota_setup(); lwic_setup(); } void loop() { // put your main code here, to run repeatedly: wifi_ota_loop(); lwic_loop(); } Git repository link for codes :- Repo","title":"main.cpp"},{"location":"WiFi/","text":"WIFI Station Mode Access Point mode","title":"Introduction"},{"location":"WiFi/#wifi","text":"","title":"WIFI"},{"location":"WiFi/#station-mode","text":"","title":"Station Mode"},{"location":"WiFi/#access-point-mode","text":"","title":"Access Point mode"},{"location":"environment/","text":"Setting up IDE What is IDE? An integrated development environment (IDE) is an application that facilitates application development. IDEs are designed to encompass all programming tasks in one application. Therefore, IDEs offer a central interface featuring all the tools a developer needs for firmware development like serial montior, editor, compiler etc. Popular IDE in opensource community Arduino Framework In opensource community, two type of environment are more popular with Arduino Framework :- Arduino IDE Visual Studio Code + PaltformIO Other Framework There are other framework also available like ESP-IDF. But its not that much popular among beginners.","title":"Setting up environment"},{"location":"environment/#setting-up-ide","text":"","title":"Setting up IDE"},{"location":"environment/#what-is-ide","text":"An integrated development environment (IDE) is an application that facilitates application development. IDEs are designed to encompass all programming tasks in one application. Therefore, IDEs offer a central interface featuring all the tools a developer needs for firmware development like serial montior, editor, compiler etc.","title":"What is IDE?"},{"location":"environment/#popular-ide-in-opensource-community","text":"","title":"Popular IDE in opensource community"},{"location":"environment/#arduino-framework","text":"In opensource community, two type of environment are more popular with Arduino Framework :- Arduino IDE Visual Studio Code + PaltformIO","title":"Arduino Framework"},{"location":"environment/#other-framework","text":"There are other framework also available like ESP-IDF. But its not that much popular among beginners.","title":"Other Framework"},{"location":"environment/Arduino_Environment/","text":"Setting up Arduino IDE Downloading and Installing Arduino IDE In order to download the Arduino IDE, visit this link, download and run the installation. Installing ESP32 add-ons for Arduino IDE In the Arduino IDE, go to File \u2013> Preferences Enter https://dl.espressif.com/dl/package_esp32_index.json into the \u201cAdditional Board Manager URLs\u201d field. Go to Tools \u2013> Board \u2013> Boards Manager. In the dialog box, that opens up, search for ESP32, and press install button for the \u201cESP32 by Espressif Systems\u201c. Now, go to Tools \u2013> Board. Now, select the ESP32 DEV Module.","title":"Arduino IDE"},{"location":"environment/Arduino_Environment/#setting-up-arduino-ide","text":"","title":"Setting up Arduino IDE"},{"location":"environment/Arduino_Environment/#downloading-and-installing-arduino-ide","text":"In order to download the Arduino IDE, visit this link, download and run the installation.","title":"Downloading and Installing Arduino IDE"},{"location":"environment/Arduino_Environment/#installing-esp32-add-ons-for-arduino-ide","text":"In the Arduino IDE, go to File \u2013> Preferences Enter https://dl.espressif.com/dl/package_esp32_index.json into the \u201cAdditional Board Manager URLs\u201d field. Go to Tools \u2013> Board \u2013> Boards Manager. In the dialog box, that opens up, search for ESP32, and press install button for the \u201cESP32 by Espressif Systems\u201c. Now, go to Tools \u2013> Board. Now, select the ESP32 DEV Module.","title":"Installing ESP32 add-ons for Arduino IDE"},{"location":"environment/Paltform_IO_Environment/","text":"Platform.IO First we need to install Microsoft Visual Studio Code. Follow the steps to download and install it. a. Go to https://code.visualstudio.com . b. Click on \u201cDownload\u201d button at the top right corner of the screen. c. You will be directed to a new page. Choose your OS there and click on it. d. You then will be directed to documentation page of VS code and your download will begin. NOTE(for beginners): Read the complete documentation page as it will help you to get comfortable with UI of VS code. e. Go to your downloaded file directory and install the file. Congrats you have completed the very step. Now we can setup Platform.IO. Follow these steps to do it. a. Open VS code and go to extension manager. b. Search for PlatformIO IDE extension. c. Click on Install.","title":"Platform IO"},{"location":"environment/Paltform_IO_Environment/#platformio","text":"First we need to install Microsoft Visual Studio Code. Follow the steps to download and install it. a. Go to https://code.visualstudio.com . b. Click on \u201cDownload\u201d button at the top right corner of the screen. c. You will be directed to a new page. Choose your OS there and click on it. d. You then will be directed to documentation page of VS code and your download will begin. NOTE(for beginners): Read the complete documentation page as it will help you to get comfortable with UI of VS code. e. Go to your downloaded file directory and install the file. Congrats you have completed the very step. Now we can setup Platform.IO. Follow these steps to do it. a. Open VS code and go to extension manager. b. Search for PlatformIO IDE extension. c. Click on Install.","title":"Platform.IO"},{"location":"mDNS/","text":"mDNS What is mDNS? Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /* ESP32 mDNS responder sample This is an example of an HTTP server that is accessible via http://esp32.local URL thanks to mDNS responder. Instructions: - Update WiFi SSID and password as necessary. - Flash the sketch to the ESP32 board - Install host software: - For Linux, install Avahi (http://avahi.org/). - For Windows, install Bonjour (http://www.apple.com/support/bonjour/). - For Mac OSX and iOS support is built in through Bonjour already. - Point your browser to http://esp32.local, you should see a response. */ #include <WiFi.h> #include <ESPmDNS.h> #include <WiFiClient.h> const char * ssid = \"sincgrid\" ; const char * password = \"sincgrid.com\" ; // TCP server at port 80 will respond to HTTP requests WiFiServer server ( 80 ); void setup ( void ) { Serial . begin ( 115200 ); // Connect to WiFi network WiFi . begin ( ssid , password ); Serial . println ( \"\" ); // Wait for connection while ( WiFi . status () != WL_CONNECTED ) { delay ( 500 ); Serial . print ( \".\" ); } Serial . println ( \"\" ); Serial . print ( \"Connected to \" ); Serial . println ( ssid ); Serial . print ( \"IP address: \" ); Serial . println ( WiFi . localIP ()); // Set up mDNS responder: // - first argument is the domain name, in this example // the fully-qualified domain name is \"esp8266.local\" // - second argument is the IP address to advertise // we send our IP address on the WiFi network if ( ! MDNS . begin ( \"esp32\" )) { Serial . println ( \"Error setting up MDNS responder!\" ); while ( 1 ) { delay ( 1000 ); } } Serial . println ( \"mDNS responder started\" ); // Start TCP (HTTP) server server . begin (); Serial . println ( \"TCP server started\" ); // Add service to MDNS-SD MDNS . addService ( \"http\" , \"tcp\" , 80 ); } void loop ( void ) { // Check if a client has connected WiFiClient client = server . available (); if ( ! client ) { return ; } Serial . println ( \"\" ); Serial . println ( \"New client\" ); // Wait for data from client to become available while ( client . connected () && ! client . available ()){ delay ( 1 ); } // Read the first line of HTTP request String req = client . readStringUntil ( '\\r' ); // First line of HTTP request looks like \"GET /path HTTP/1.1\" // Retrieve the \"/path\" part by finding the spaces int addr_start = req . indexOf ( ' ' ); int addr_end = req . indexOf ( ' ' , addr_start + 1 ); if ( addr_start == - 1 || addr_end == - 1 ) { Serial . print ( \"Invalid request: \" ); Serial . println ( req ); return ; } req = req . substring ( addr_start + 1 , addr_end ); Serial . print ( \"Request: \" ); Serial . println ( req ); String s ; if ( req == \"/\" ) { IPAddress ip = WiFi . localIP (); String ipStr = String ( ip [ 0 ]) + '.' + String ( ip [ 1 ]) + '.' + String ( ip [ 2 ]) + '.' + String ( ip [ 3 ]); s = \"HTTP/1.1 200 OK \\r\\n Content-Type: text/html \\r\\n\\r\\n <!DOCTYPE HTML> \\r\\n <html>Hello from ESP32 at \" ; s += ipStr ; s += \"</html> \\r\\n\\r\\n \" ; Serial . println ( \"Sending 200\" ); } else { s = \"HTTP/1.1 404 Not Found \\r\\n\\r\\n \" ; Serial . println ( \"Sending 404\" ); } client . print ( s ); client . stop (); Serial . println ( \"Done with client\" ); } Testing discovery in mDNS Browser chrome extension Example in browser","title":"mDNS"},{"location":"mDNS/#mdns","text":"","title":"mDNS"},{"location":"mDNS/#what-is-mdns","text":"","title":"What is mDNS?"},{"location":"mDNS/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /* ESP32 mDNS responder sample This is an example of an HTTP server that is accessible via http://esp32.local URL thanks to mDNS responder. Instructions: - Update WiFi SSID and password as necessary. - Flash the sketch to the ESP32 board - Install host software: - For Linux, install Avahi (http://avahi.org/). - For Windows, install Bonjour (http://www.apple.com/support/bonjour/). - For Mac OSX and iOS support is built in through Bonjour already. - Point your browser to http://esp32.local, you should see a response. */ #include <WiFi.h> #include <ESPmDNS.h> #include <WiFiClient.h> const char * ssid = \"sincgrid\" ; const char * password = \"sincgrid.com\" ; // TCP server at port 80 will respond to HTTP requests WiFiServer server ( 80 ); void setup ( void ) { Serial . begin ( 115200 ); // Connect to WiFi network WiFi . begin ( ssid , password ); Serial . println ( \"\" ); // Wait for connection while ( WiFi . status () != WL_CONNECTED ) { delay ( 500 ); Serial . print ( \".\" ); } Serial . println ( \"\" ); Serial . print ( \"Connected to \" ); Serial . println ( ssid ); Serial . print ( \"IP address: \" ); Serial . println ( WiFi . localIP ()); // Set up mDNS responder: // - first argument is the domain name, in this example // the fully-qualified domain name is \"esp8266.local\" // - second argument is the IP address to advertise // we send our IP address on the WiFi network if ( ! MDNS . begin ( \"esp32\" )) { Serial . println ( \"Error setting up MDNS responder!\" ); while ( 1 ) { delay ( 1000 ); } } Serial . println ( \"mDNS responder started\" ); // Start TCP (HTTP) server server . begin (); Serial . println ( \"TCP server started\" ); // Add service to MDNS-SD MDNS . addService ( \"http\" , \"tcp\" , 80 ); } void loop ( void ) { // Check if a client has connected WiFiClient client = server . available (); if ( ! client ) { return ; } Serial . println ( \"\" ); Serial . println ( \"New client\" ); // Wait for data from client to become available while ( client . connected () && ! client . available ()){ delay ( 1 ); } // Read the first line of HTTP request String req = client . readStringUntil ( '\\r' ); // First line of HTTP request looks like \"GET /path HTTP/1.1\" // Retrieve the \"/path\" part by finding the spaces int addr_start = req . indexOf ( ' ' ); int addr_end = req . indexOf ( ' ' , addr_start + 1 ); if ( addr_start == - 1 || addr_end == - 1 ) { Serial . print ( \"Invalid request: \" ); Serial . println ( req ); return ; } req = req . substring ( addr_start + 1 , addr_end ); Serial . print ( \"Request: \" ); Serial . println ( req ); String s ; if ( req == \"/\" ) { IPAddress ip = WiFi . localIP (); String ipStr = String ( ip [ 0 ]) + '.' + String ( ip [ 1 ]) + '.' + String ( ip [ 2 ]) + '.' + String ( ip [ 3 ]); s = \"HTTP/1.1 200 OK \\r\\n Content-Type: text/html \\r\\n\\r\\n <!DOCTYPE HTML> \\r\\n <html>Hello from ESP32 at \" ; s += ipStr ; s += \"</html> \\r\\n\\r\\n \" ; Serial . println ( \"Sending 200\" ); } else { s = \"HTTP/1.1 404 Not Found \\r\\n\\r\\n \" ; Serial . println ( \"Sending 404\" ); } client . print ( s ); client . stop (); Serial . println ( \"Done with client\" ); }","title":"Code"},{"location":"mDNS/#testing-discovery-in-mdns-browser-chrome-extension","text":"","title":"Testing discovery in mDNS Browser chrome extension"},{"location":"mDNS/#example-in-browser","text":"","title":"Example in browser"},{"location":"pinouts/","text":"Pinout These are list of pins connected on your IOT-A-SYNC board. For ESP-32 datasheet visit : https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf For ESP32-Wroom datasheet visit : https://www.espressif.com/sites/default/files/documentation/esp32-wroom-32_datasheet_en.pdf GPIO INPUT OUTPUT NOTES Peripheral pins Available on header 0 pulled up OK outputs PWM signal at boot YES 1 TX pin OK debut output at boot YES 2 OK RX pin connected to on-board LED (in some wroom) LED/EC_17 YES 3 OK OK HIGH at boot YES 4 OK OK SWITCH/EC_18 YES 5 X X outputs PWM signal at boot LoRa_NSS(SS/CS) YES 6 X X connected to the integrated SPI flash NOT REQUIRED 7 X X connected to the integrated SPI flash NOT REQUIRED 8 X X connected to the integrated SPI flash NOT REQUIRED 9 X X connected to the integrated SPI flash NOT REQUIRED 10 X X connected to the integrated SPI flash NOT REQUIRED 11 OK OK connected to the integrated SPI flash NOT REQUIRED 12 OK OK Boot fail if pulled HIGH YES 13 OK OK YES 14 OK OK outputs PWM signal at boot YES 15 OK OK outputs PWM signal at boot IR_RX YES 16 OK OK LoRa_DIO0 YES 17 OK OK IR_TX YES 18 OK OK LoRa_SCK YES 19 OK OK LoRa_MISO YES 21 OK OK SDA YES 22 OK OK SCL YES 23 OK OK LoRa_MOSI YES 25 OK OK EC_1 YES 26 OK OK EC_2 YES 27 OK OK LoRa_RESET YES 32 OK OK EC_9 YES 33 OK OK EC_10 YES 34 OK input only EC_4 YES 35 OK input only EC_5 YES 36 OK input only EC_6 YES 39 OK input only EC_3 YES","title":"IOT-A-SYNC Pinout"},{"location":"pinouts/#pinout","text":"These are list of pins connected on your IOT-A-SYNC board. For ESP-32 datasheet visit : https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf For ESP32-Wroom datasheet visit : https://www.espressif.com/sites/default/files/documentation/esp32-wroom-32_datasheet_en.pdf GPIO INPUT OUTPUT NOTES Peripheral pins Available on header 0 pulled up OK outputs PWM signal at boot YES 1 TX pin OK debut output at boot YES 2 OK RX pin connected to on-board LED (in some wroom) LED/EC_17 YES 3 OK OK HIGH at boot YES 4 OK OK SWITCH/EC_18 YES 5 X X outputs PWM signal at boot LoRa_NSS(SS/CS) YES 6 X X connected to the integrated SPI flash NOT REQUIRED 7 X X connected to the integrated SPI flash NOT REQUIRED 8 X X connected to the integrated SPI flash NOT REQUIRED 9 X X connected to the integrated SPI flash NOT REQUIRED 10 X X connected to the integrated SPI flash NOT REQUIRED 11 OK OK connected to the integrated SPI flash NOT REQUIRED 12 OK OK Boot fail if pulled HIGH YES 13 OK OK YES 14 OK OK outputs PWM signal at boot YES 15 OK OK outputs PWM signal at boot IR_RX YES 16 OK OK LoRa_DIO0 YES 17 OK OK IR_TX YES 18 OK OK LoRa_SCK YES 19 OK OK LoRa_MISO YES 21 OK OK SDA YES 22 OK OK SCL YES 23 OK OK LoRa_MOSI YES 25 OK OK EC_1 YES 26 OK OK EC_2 YES 27 OK OK LoRa_RESET YES 32 OK OK EC_9 YES 33 OK OK EC_10 YES 34 OK input only EC_4 YES 35 OK input only EC_5 YES 36 OK input only EC_6 YES 39 OK input only EC_3 YES","title":"Pinout"}]}