{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to IOT-A-SYNC Documentation This is the documentation for the IOT-A-SYNC board. What is IOT-A-SYNC? IOT-A-SYNC is rapid prototyping development board for Internet of Things (IOT) applications. This board is powered by ESP32 sytem on chip microcontroller with Xtensa dual-core. Esp32 officially supports Arduino and ESP-IDF framework built around FreeRTOS. NIC Interfaces available on IOTA-SYNC IOT-A-SYNC supports multiple globally accepted network interfaces for IOT devices communication. Various wireless communicaton options it supports are WIFI, BLE,NFC, LoRa PHY. NIC Interfaces in terms of range In terms of range of commuincation, For Short range, it supports NFC. For Medium range, it supports Wi-Fi (802.11 b/g/n) and Bluetooth (v4.2 BR/EDR and BLE). For Long range, it supports LoRa communication. Topolgy of network that can be demonstrated IOT-A-SYNC also support network topology like Star and Mesh for creating Wireless sensor network(WSN). Programming and Debugging interfaces available Programming of IOT-A-SYNC is supported by onboard USB-to-Serial converter as well as it also supports external JTAG interface for programming and debugging. On board preipherals Other on board peripherals that are available icludes:- On-Board Led, Switch, Oled(128x64) screen, BME280 sensor (provides Temperatue, Humidity, Pressue), IR transmitter led and IR Receiver sensor. All I/O pins are provide on 0.1\" male as well as female header, as well as few distictive feature I/O are available on 3 Pin JST connector compatible with commonly available sensors and other modules. The 180-point breadboard further facilitates temporary/external circuit testing via jumpers on board itself. Low power mode Also, for low power WSN, shorting jumpers are provided to limit power usuage. Some example code repository URL for ESP32-IOTA-SYNC repository: ESP32-IOTA-SYNC URL for Design and Practicum Workshop: DPW","title":"Introduction"},{"location":"#welcome-to-iot-a-sync-documentation","text":"This is the documentation for the IOT-A-SYNC board.","title":"Welcome to IOT-A-SYNC Documentation"},{"location":"#what-is-iot-a-sync","text":"IOT-A-SYNC is rapid prototyping development board for Internet of Things (IOT) applications. This board is powered by ESP32 sytem on chip microcontroller with Xtensa dual-core. Esp32 officially supports Arduino and ESP-IDF framework built around FreeRTOS.","title":"What is IOT-A-SYNC?"},{"location":"#nic-interfaces-available-on-iota-sync","text":"IOT-A-SYNC supports multiple globally accepted network interfaces for IOT devices communication. Various wireless communicaton options it supports are WIFI, BLE,NFC, LoRa PHY.","title":"NIC Interfaces available on IOTA-SYNC"},{"location":"#nic-interfaces-in-terms-of-range","text":"In terms of range of commuincation, For Short range, it supports NFC. For Medium range, it supports Wi-Fi (802.11 b/g/n) and Bluetooth (v4.2 BR/EDR and BLE). For Long range, it supports LoRa communication.","title":"NIC Interfaces in terms of range"},{"location":"#topolgy-of-network-that-can-be-demonstrated","text":"IOT-A-SYNC also support network topology like Star and Mesh for creating Wireless sensor network(WSN).","title":"Topolgy of network that can be demonstrated"},{"location":"#programming-and-debugging-interfaces-available","text":"Programming of IOT-A-SYNC is supported by onboard USB-to-Serial converter as well as it also supports external JTAG interface for programming and debugging.","title":"Programming and Debugging interfaces available"},{"location":"#on-board-preipherals","text":"Other on board peripherals that are available icludes:- On-Board Led, Switch, Oled(128x64) screen, BME280 sensor (provides Temperatue, Humidity, Pressue), IR transmitter led and IR Receiver sensor. All I/O pins are provide on 0.1\" male as well as female header, as well as few distictive feature I/O are available on 3 Pin JST connector compatible with commonly available sensors and other modules. The 180-point breadboard further facilitates temporary/external circuit testing via jumpers on board itself.","title":"On board preipherals"},{"location":"#low-power-mode","text":"Also, for low power WSN, shorting jumpers are provided to limit power usuage.","title":"Low power mode"},{"location":"#some-example-code-repository","text":"URL for ESP32-IOTA-SYNC repository: ESP32-IOTA-SYNC URL for Design and Practicum Workshop: DPW","title":"Some example code repository"},{"location":"Arduino/","text":"Basic Functions that can be used with ESP32 ESP32 uses many functions that are very similar to many arduino boards, the only difference is that some parameters have to be changed according to the hardware limitation of this board. Pinout diagram Basic functions The pins of ESP32 is connected to various connectors of IOT-A-SYNC, verify it before starting Some of the basic functions that can be used are given below: pinMode This function lets the controller know weather the GPIO pin will act as Input or Output. digitalWrite This command instructs a particular GPIO pin to go logic HIGH or logic LOW as per the arguments. 1 2 digitalWrite ( GPIO_pin_number , HIGH ); //This gives logic HIGH (3.3V) digitalWrite ( GPIO_pin_number , LOW ); //This gives logic LOW (0V) digitalRead This command checks the digital logic voltage at a particular pin specified as arguments. It returns a boolean TRUE if logic detected is HIGH at that pin and FALSE if logic LOW is detected. 1 digitalRead ( GPIO_pin_number ); analogRead This reads the analog value at the pin specified as argument. Since it has 12bit ADC (analog-to-digital convertor) it can only read voltages in discrete intervals of 2^8 (i.e 2^(no. of bits)), therefore it can read upto an accuracy of 3.3/(2^8) = 0.805mV. 1 analogRead ( GPIO_pin_number ); Writing Ananlog values ESP32 does not have analogWrite() function. So we use different methods to generate analog signals. One such method is using PWM and other is using the inbuilt DAC hardware. Using DAC DacWrite(GPIO_pin,value); //'value' defined ranges from 0 to 4095 as it uses a 12 bit DAC. Using PWM Here we use the concept that in a pulsed wave the average output is (max Voltage)X(duty cycle). Thus this method can be used to vary the brightness of an LED, vary the sound in a speaker, vary the speed of motors and many more. For this, we define a particular frequency with which we want to send PWM (For lighting LEDs it should be much higher than the persistence of vision, for motors it should be according to the time constant). The duty cycle can be varied by keeping the output HIGH for some time and LOW for the rest of the time. See this example to get an overview on how to code for PWM. delay() This function lets the controller to wait for certain millisecons (as specified in the argumenmt) before executing the next instruction. When the delay is executed, the controller cannot do any other task, it\u2019s like being in a \u2018paused\u2019 state. 1 delay ( 1000 ); //delay of 1000ms i.e.1sec Similar function is delayMicroseconds() . Millis() - This function returns the time in milliseconds that have been passed since program execution has started. It has overflow time of about 50 days! Interrupts Interrupt is a signal emitted by hardware or software when a process or an event needs immediate attention. It alerts the processor to a high priority process requiring interruption of the current working process. In I/O devices one of the bus control lines is dedicated for this purpose and is called the Interrupt Service Routine (ISR). When a device raises an interrupt at lets say process i, the processor first completes the execution of instruction i. Then it loads the Program Counter (PC) with the address of the first instruction of the ISR. Before loading the Program Counter with the address, the address of the interrupted instruction is moved to a temporary location. Therefore, after handling the interrupt the processor can continue with process i+1. Interrupts here can be callled in four ways/Modes:- LOW to trigger the interrupt whenever the pin is low, CHANGE to trigger the interrupt whenever the pin changes value RISING to trigger when the pin goes from low to high, FALLING for when the pin goes from high to low. All GPIO pins can be configered as Interrupt pins attachInterrupt() This tells the controller on which pin the interrupt has to be attached and what ISR does it corresponds. attachInterrupt(GPIO_Pin_no, ISR, Mode); 1 2 //'ISR' is a function which is called when interrupt is received. ISR has to be as small as possible. //'Mode' specifies the event when interrupt should be called. detachInterrupt(pin_no) It disables the interrupt at that pin. Serial Class This is a class predefined in the \u201cArduino.h\u201d library for serial communication. It consists of many functions which are used for manipulating data. This has extreme importance in UART communication. Visit: https://www.arduino.cc/reference/en/language/functions/communication/serial/ to know more about functions available in this class.","title":"Arduino FrameWork"},{"location":"Arduino/#basic-functions-that-can-be-used-with-esp32","text":"ESP32 uses many functions that are very similar to many arduino boards, the only difference is that some parameters have to be changed according to the hardware limitation of this board.","title":"Basic Functions that can be used with ESP32"},{"location":"Arduino/#pinout-diagram","text":"","title":"Pinout diagram"},{"location":"Arduino/#basic-functions","text":"The pins of ESP32 is connected to various connectors of IOT-A-SYNC, verify it before starting Some of the basic functions that can be used are given below:","title":"Basic functions"},{"location":"Arduino/#pinmode","text":"This function lets the controller know weather the GPIO pin will act as Input or Output.","title":"pinMode"},{"location":"Arduino/#digitalwrite","text":"This command instructs a particular GPIO pin to go logic HIGH or logic LOW as per the arguments. 1 2 digitalWrite ( GPIO_pin_number , HIGH ); //This gives logic HIGH (3.3V) digitalWrite ( GPIO_pin_number , LOW ); //This gives logic LOW (0V)","title":"digitalWrite"},{"location":"Arduino/#digitalread","text":"This command checks the digital logic voltage at a particular pin specified as arguments. It returns a boolean TRUE if logic detected is HIGH at that pin and FALSE if logic LOW is detected. 1 digitalRead ( GPIO_pin_number );","title":"digitalRead"},{"location":"Arduino/#analogread","text":"This reads the analog value at the pin specified as argument. Since it has 12bit ADC (analog-to-digital convertor) it can only read voltages in discrete intervals of 2^8 (i.e 2^(no. of bits)), therefore it can read upto an accuracy of 3.3/(2^8) = 0.805mV. 1 analogRead ( GPIO_pin_number );","title":"analogRead"},{"location":"Arduino/#writing-ananlog-values","text":"ESP32 does not have analogWrite() function. So we use different methods to generate analog signals. One such method is using PWM and other is using the inbuilt DAC hardware.","title":"Writing Ananlog values"},{"location":"Arduino/#using-dac","text":"DacWrite(GPIO_pin,value); //'value' defined ranges from 0 to 4095 as it uses a 12 bit DAC.","title":"Using DAC"},{"location":"Arduino/#using-pwm","text":"Here we use the concept that in a pulsed wave the average output is (max Voltage)X(duty cycle). Thus this method can be used to vary the brightness of an LED, vary the sound in a speaker, vary the speed of motors and many more. For this, we define a particular frequency with which we want to send PWM (For lighting LEDs it should be much higher than the persistence of vision, for motors it should be according to the time constant). The duty cycle can be varied by keeping the output HIGH for some time and LOW for the rest of the time. See this example to get an overview on how to code for PWM.","title":"Using PWM"},{"location":"Arduino/#delay","text":"This function lets the controller to wait for certain millisecons (as specified in the argumenmt) before executing the next instruction. When the delay is executed, the controller cannot do any other task, it\u2019s like being in a \u2018paused\u2019 state. 1 delay ( 1000 ); //delay of 1000ms i.e.1sec Similar function is delayMicroseconds() . Millis() - This function returns the time in milliseconds that have been passed since program execution has started. It has overflow time of about 50 days!","title":"delay()"},{"location":"Arduino/#interrupts","text":"Interrupt is a signal emitted by hardware or software when a process or an event needs immediate attention. It alerts the processor to a high priority process requiring interruption of the current working process. In I/O devices one of the bus control lines is dedicated for this purpose and is called the Interrupt Service Routine (ISR). When a device raises an interrupt at lets say process i, the processor first completes the execution of instruction i. Then it loads the Program Counter (PC) with the address of the first instruction of the ISR. Before loading the Program Counter with the address, the address of the interrupted instruction is moved to a temporary location. Therefore, after handling the interrupt the processor can continue with process i+1. Interrupts here can be callled in four ways/Modes:- LOW to trigger the interrupt whenever the pin is low, CHANGE to trigger the interrupt whenever the pin changes value RISING to trigger when the pin goes from low to high, FALLING for when the pin goes from high to low. All GPIO pins can be configered as Interrupt pins","title":"Interrupts"},{"location":"Arduino/#attachinterrupt","text":"This tells the controller on which pin the interrupt has to be attached and what ISR does it corresponds. attachInterrupt(GPIO_Pin_no, ISR, Mode); 1 2 //'ISR' is a function which is called when interrupt is received. ISR has to be as small as possible. //'Mode' specifies the event when interrupt should be called. detachInterrupt(pin_no) It disables the interrupt at that pin. Serial Class This is a class predefined in the \u201cArduino.h\u201d library for serial communication. It consists of many functions which are used for manipulating data. This has extreme importance in UART communication. Visit: https://www.arduino.cc/reference/en/language/functions/communication/serial/ to know more about functions available in this class.","title":"attachInterrupt()"},{"location":"Driver/","text":"CH340 Driver for Windows For manual installation of driver of CH340 USB to serial converter, follow the following steps: Download driver from this link -> Driver Right click on \u2018This PC\u2019 and go to properties. Select Device Manager from the left panel. Expand USB options available Right click on CH340 Select Update driver Select browse option Extract the downloaded folder from the first step. Browse to the extracted folder Follow further instructions of your computer and your CH340 device will be installed.","title":"Driver"},{"location":"Driver/#ch340-driver-for-windows","text":"For manual installation of driver of CH340 USB to serial converter, follow the following steps: Download driver from this link -> Driver Right click on \u2018This PC\u2019 and go to properties. Select Device Manager from the left panel. Expand USB options available Right click on CH340 Select Update driver Select browse option Extract the downloaded folder from the first step. Browse to the extracted folder Follow further instructions of your computer and your CH340 device will be installed.","title":"CH340 Driver for Windows"},{"location":"environment/","text":"Setting up IDE What is IDE? An integrated development environment (IDE) is an application that facilitates application development. IDEs are designed to encompass all programming tasks in one application. Therefore, IDEs offer a central interface featuring all the tools a developer needs for firmware development like serial montior, editor, compiler etc. Popular IDE in opensource community Arduino Framework In opensource community, two type of environment are more popular with Arduino Framework :- Arduino IDE Visual Studio Code + PaltformIO Other Framework There are other framework also available like ESP-IDF. But its not that much popular among beginners.","title":"Setting up environment"},{"location":"environment/#setting-up-ide","text":"","title":"Setting up IDE"},{"location":"environment/#what-is-ide","text":"An integrated development environment (IDE) is an application that facilitates application development. IDEs are designed to encompass all programming tasks in one application. Therefore, IDEs offer a central interface featuring all the tools a developer needs for firmware development like serial montior, editor, compiler etc.","title":"What is IDE?"},{"location":"environment/#popular-ide-in-opensource-community","text":"","title":"Popular IDE in opensource community"},{"location":"environment/#arduino-framework","text":"In opensource community, two type of environment are more popular with Arduino Framework :- Arduino IDE Visual Studio Code + PaltformIO","title":"Arduino Framework"},{"location":"environment/#other-framework","text":"There are other framework also available like ESP-IDF. But its not that much popular among beginners.","title":"Other Framework"},{"location":"environment/Arduino_Environment/","text":"Setting up Arduino IDE Downloading and Installing Arduino IDE In order to download the Arduino IDE, visit this link, download and run the installation. Installing ESP32 add-ons for Arduino IDE In the Arduino IDE, go to File \u2013> Preferences Enter https://dl.espressif.com/dl/package_esp32_index.json into the \u201cAdditional Board Manager URLs\u201d field. Go to Tools \u2013> Board \u2013> Boards Manager. In the dialog box, that opens up, search for ESP32, and press install button for the \u201cESP32 by Espressif Systems\u201c. Now, go to Tools \u2013> Board. Now, select the ESP32 DEV Module.","title":"Arduino IDE"},{"location":"environment/Arduino_Environment/#setting-up-arduino-ide","text":"","title":"Setting up Arduino IDE"},{"location":"environment/Arduino_Environment/#downloading-and-installing-arduino-ide","text":"In order to download the Arduino IDE, visit this link, download and run the installation.","title":"Downloading and Installing Arduino IDE"},{"location":"environment/Arduino_Environment/#installing-esp32-add-ons-for-arduino-ide","text":"In the Arduino IDE, go to File \u2013> Preferences Enter https://dl.espressif.com/dl/package_esp32_index.json into the \u201cAdditional Board Manager URLs\u201d field. Go to Tools \u2013> Board \u2013> Boards Manager. In the dialog box, that opens up, search for ESP32, and press install button for the \u201cESP32 by Espressif Systems\u201c. Now, go to Tools \u2013> Board. Now, select the ESP32 DEV Module.","title":"Installing ESP32 add-ons for Arduino IDE"},{"location":"environment/Paltform_IO_Environment/","text":"Platform.IO First we need to install Microsoft Visual Studio Code. Follow the steps to download and install it. a. Go to https://code.visualstudio.com . b. Click on \u201cDownload\u201d button at the top right corner of the screen. c. You will be directed to a new page. Choose your OS there and click on it. d. You then will be directed to documentation page of VS code and your download will begin. NOTE(for beginners): Read the complete documentation page as it will help you to get comfortable with UI of VS code. e. Go to your downloaded file directory and install the file. Congrats you have completed the very step. Now we can setup Platform.IO. Follow these steps to do it. a. Open VS code and go to extension manager. b. Search for PlatformIO IDE extension. c. Click on Install.","title":"Platform IO"},{"location":"environment/Paltform_IO_Environment/#platformio","text":"First we need to install Microsoft Visual Studio Code. Follow the steps to download and install it. a. Go to https://code.visualstudio.com . b. Click on \u201cDownload\u201d button at the top right corner of the screen. c. You will be directed to a new page. Choose your OS there and click on it. d. You then will be directed to documentation page of VS code and your download will begin. NOTE(for beginners): Read the complete documentation page as it will help you to get comfortable with UI of VS code. e. Go to your downloaded file directory and install the file. Congrats you have completed the very step. Now we can setup Platform.IO. Follow these steps to do it. a. Open VS code and go to extension manager. b. Search for PlatformIO IDE extension. c. Click on Install.","title":"Platform.IO"},{"location":"pinouts/","text":"Pinout These are list of pins connected on your IOT-A-SYNC board. For ESP-32 datasheet visit : https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf For ESP32-Wroom datasheet visit : https://www.espressif.com/sites/default/files/documentation/esp32-wroom-32_datasheet_en.pdf GPIO INPUT OUTPUT NOTES Peripheral pins Available on header 0 pulled up OK outputs PWM signal at boot YES 1 TX pin OK debut output at boot YES 2 OK RX pin connected to on-board LED (in some wroom) LED/EC_17 YES 3 OK OK HIGH at boot YES 4 OK OK SWITCH/EC_18 YES 5 X X outputs PWM signal at boot LoRa_NSS(SS/CS) YES 6 X X connected to the integrated SPI flash NOT REQUIRED 7 X X connected to the integrated SPI flash NOT REQUIRED 8 X X connected to the integrated SPI flash NOT REQUIRED 9 X X connected to the integrated SPI flash NOT REQUIRED 10 X X connected to the integrated SPI flash NOT REQUIRED 11 OK OK connected to the integrated SPI flash NOT REQUIRED 12 OK OK Boot fail if pulled HIGH YES 13 OK OK YES 14 OK OK outputs PWM signal at boot YES 15 OK OK outputs PWM signal at boot IR_RX YES 16 OK OK LoRa_DIO0 YES 17 OK OK IR_TX YES 18 OK OK LoRa_SCK YES 19 OK OK LoRa_MISO YES 21 OK OK SDA YES 22 OK OK SCL YES 23 OK OK LoRa_MOSI YES 25 OK OK EC_1 YES 26 OK OK EC_2 YES 27 OK OK LoRa_RESET YES 32 OK OK EC_9 YES 33 OK OK EC_10 YES 34 OK input only EC_4 YES 35 OK input only EC_5 YES 36 OK input only EC_6 YES 39 OK input only EC_3 YES","title":"Pinout"},{"location":"pinouts/#pinout","text":"These are list of pins connected on your IOT-A-SYNC board. For ESP-32 datasheet visit : https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf For ESP32-Wroom datasheet visit : https://www.espressif.com/sites/default/files/documentation/esp32-wroom-32_datasheet_en.pdf GPIO INPUT OUTPUT NOTES Peripheral pins Available on header 0 pulled up OK outputs PWM signal at boot YES 1 TX pin OK debut output at boot YES 2 OK RX pin connected to on-board LED (in some wroom) LED/EC_17 YES 3 OK OK HIGH at boot YES 4 OK OK SWITCH/EC_18 YES 5 X X outputs PWM signal at boot LoRa_NSS(SS/CS) YES 6 X X connected to the integrated SPI flash NOT REQUIRED 7 X X connected to the integrated SPI flash NOT REQUIRED 8 X X connected to the integrated SPI flash NOT REQUIRED 9 X X connected to the integrated SPI flash NOT REQUIRED 10 X X connected to the integrated SPI flash NOT REQUIRED 11 OK OK connected to the integrated SPI flash NOT REQUIRED 12 OK OK Boot fail if pulled HIGH YES 13 OK OK YES 14 OK OK outputs PWM signal at boot YES 15 OK OK outputs PWM signal at boot IR_RX YES 16 OK OK LoRa_DIO0 YES 17 OK OK IR_TX YES 18 OK OK LoRa_SCK YES 19 OK OK LoRa_MISO YES 21 OK OK SDA YES 22 OK OK SCL YES 23 OK OK LoRa_MOSI YES 25 OK OK EC_1 YES 26 OK OK EC_2 YES 27 OK OK LoRa_RESET YES 32 OK OK EC_9 YES 33 OK OK EC_10 YES 34 OK input only EC_4 YES 35 OK input only EC_5 YES 36 OK input only EC_6 YES 39 OK input only EC_3 YES","title":"Pinout"}]}